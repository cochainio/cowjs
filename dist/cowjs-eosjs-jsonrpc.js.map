{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./node_modules/axios/lib/utils.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/bytebuffer/dist/bytebuffer.js","webpack:///./node_modules/axios/lib/defaults.js","webpack:///./node_modules/axios/lib/helpers/bind.js","webpack:///./node_modules/axios/lib/adapters/xhr.js","webpack:///./node_modules/axios/lib/core/createError.js","webpack:///./node_modules/axios/lib/cancel/isCancel.js","webpack:///./node_modules/axios/lib/cancel/Cancel.js","webpack:///./node_modules/eosjs/src/eosjs-numeric.ts?4851","webpack:///./src/cowjs-eosjs/eosjs-jsonrpc.ts","webpack:///./node_modules/axios/index.js","webpack:///./node_modules/axios/lib/axios.js","webpack:///./node_modules/is-buffer/index.js","webpack:///./node_modules/axios/lib/core/Axios.js","webpack:///./node_modules/axios/lib/helpers/normalizeHeaderName.js","webpack:///./node_modules/axios/lib/core/settle.js","webpack:///./node_modules/axios/lib/core/enhanceError.js","webpack:///./node_modules/axios/lib/helpers/buildURL.js","webpack:///./node_modules/axios/lib/helpers/parseHeaders.js","webpack:///./node_modules/axios/lib/helpers/isURLSameOrigin.js","webpack:///./node_modules/axios/lib/helpers/btoa.js","webpack:///./node_modules/axios/lib/helpers/cookies.js","webpack:///./node_modules/axios/lib/core/InterceptorManager.js","webpack:///./node_modules/axios/lib/core/dispatchRequest.js","webpack:///./node_modules/axios/lib/core/transformData.js","webpack:///./node_modules/axios/lib/helpers/isAbsoluteURL.js","webpack:///./node_modules/axios/lib/helpers/combineURLs.js","webpack:///./node_modules/axios/lib/cancel/CancelToken.js","webpack:///./node_modules/axios/lib/helpers/spread.js","webpack:///./node_modules/long/dist/long.js","webpack:///./node_modules/eosjs/src/ripemd.js"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","isBuffer","toString","isArray","val","isObject","isFunction","forEach","obj","fn","length","isArrayBuffer","isFormData","FormData","isArrayBufferView","ArrayBuffer","isView","buffer","isString","isNumber","isUndefined","isDate","isFile","isBlob","isStream","pipe","isURLSearchParams","URLSearchParams","isStandardBrowserEnv","navigator","product","document","merge","result","assignValue","arguments","extend","b","thisArg","trim","str","replace","cachedSetTimeout","cachedClearTimeout","process","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","this","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","Array","push","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","undefined","Long","ByteBuffer","capacity","littleEndian","noAssert","DEFAULT_CAPACITY","DEFAULT_ENDIAN","DEFAULT_NOASSERT","RangeError","EMPTY_BUFFER","view","Uint8Array","offset","markedOffset","limit","VERSION","LITTLE_ENDIAN","BIG_ENDIAN","ByteBufferPrototype","__isByteBuffer__","configurable","stringFromCharCode","String","fromCharCode","stringSource","charCodeAt","stringDestination","cs","ps","join","ieee754_read","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","Infinity","Math","pow","ieee754_write","rt","abs","isNaN","floor","log","LN2","accessor","allocate","buffers","encoding","k","isByteBuffer","wrap","bi","bb","set","subarray","type","fromBase64","fromHex","fromBinary","fromUTF8","fromDebug","TypeError","clone","byteOffset","byteLength","writeBitSet","relative","start","bits","bytes","bit","writeVarint32","writeByte","readBitSet","ret","readVarint32","readByte","readBytes","slice","writeBytes","append","writeInt8","capacity0","resize","readInt8","writeUint8","capacity1","writeUInt8","readUint8","readUInt8","writeInt16","capacity2","writeShort","readInt16","readShort","writeUint16","capacity3","writeUInt16","readUint16","readUInt16","writeInt32","capacity4","writeInt","readInt32","readInt","writeUint32","capacity5","writeUInt32","readUint32","readUInt32","writeInt64","fromNumber","fromString","capacity6","lo","low","hi","high","writeLong","readInt64","readLong","writeUint64","capacity7","writeUInt64","readUint64","readUInt64","writeFloat32","capacity8","writeFloat","readFloat32","readFloat","writeFloat64","capacity9","writeDouble","readFloat64","readDouble","MAX_VARINT32_BYTES","calculateVarint32","zigZagEncode32","zigZagDecode32","size","capacity10","writeVarint32ZigZag","err","readVarint32ZigZag","MAX_VARINT64_BYTES","calculateVarint64","part0","toInt","part1","shiftRightUnsigned","part2","zigZagEncode64","unsigned","toSigned","shiftLeft","xor","shiftRight","toUnsigned","zigZagDecode64","and","ONE","negate","writeVarint64","capacity11","writeVarint64ZigZag","readVarint64","fromBits","readVarint64ZigZag","writeCString","utfx","calculateUTF16asUTF8","capacity12","encodeUTF16toUTF8","readCString","sd","decodeUTF8toUTF16","string","writeIString","capacity13","readIString","readUTF8String","METRICS_BYTES","METRICS_CHARS","writeUTF8String","capacity14","writeString","calculateUTF8Chars","calculateUTF8Bytes","calculateString","metrics","decodeUTF8","cp","UTF8toUTF16","readString","writeVString","capacity15","readVString","source","capacity16","appendTo","target","assert","clear","copy","compact","begin","end","copyTo","targetOffset","sourceOffset","sourceLimit","targetRelative","ensureCapacity","current","fill","flip","mark","order","LE","BE","bigEndian","prepend","diff","prependTo","printDebug","out","console","toDebug","remaining","reset","reverse","skip","toBuffer","forceCopy","toArrayBuffer","toUTF8","toBase64","toHex","toBinary","toColumns","lxiv","aout","ain","encode","src","dst","decode","t1","t2","fail","test","btoa","atob","b64","chars","parts","charCode","columns","hex","asc","toUpperCase","ch","j","rs","ho","hm","hl","charAt","parseInt","substring","isFinite","MAX_CODEPOINT","encodeUTF8","indexOf","UTF16toUTF8","c1","c2","calculateCodePoint","calculateUTF8","utils","normalizeHeaderName","DEFAULT_CONTENT_TYPE","Content-Type","setContentTypeIfUnset","headers","adapter","defaults","XMLHttpRequest","transformRequest","data","JSON","stringify","transformResponse","parse","xsrfCookieName","xsrfHeaderName","maxContentLength","validateStatus","status","common","Accept","method","settle","buildURL","parseHeaders","isURLSameOrigin","createError","config","Promise","resolve","reject","requestData","requestHeaders","request","loadEvent","xDomain","XDomainRequest","url","onprogress","ontimeout","auth","username","password","Authorization","open","params","paramsSerializer","readyState","responseURL","responseHeaders","getAllResponseHeaders","response","responseType","responseText","statusText","onerror","cookies","xsrfValue","withCredentials","read","toLowerCase","setRequestHeader","onDownloadProgress","addEventListener","onUploadProgress","upload","cancelToken","promise","then","cancel","abort","send","enhanceError","message","code","error","__CANCEL__","Cancel","ripemd160","RIPEMD160","hash","base58Chars","base64Chars","base58Map","base58M","create_base58_map","base64Map","base64M","create_base64_map","base58ToBinary","carry","x","publicKeyDataSize","digestSuffixRipemd160","suffix","stringToKey","whole","digest","keyToString","prefix","bignum","minDigits","bignum_1","__values","bignum_1_1","next","done","bignum_2","bignum_2_1","__spread","binaryToBase58","convertLegacyPublicKey","substr","publicKeyToString","stringToPublicKey","arrayToHex","data_1","eosjs_jsonrpc_values","data_1_1","eosjs_jsonrpc_JsonRpc","JsonRpc","endpoint","baseURL","api","axios_default","get_abi","account_name","abiStr","abi","get_account","get_block_header_state","block_num_or_id","get_block","req","num_start","num_end","num_asc","include_transactions","id","post","block","blocks","ref_block_prefix","bytebuffer","timestamp","endsWith","num","block_num","get_code","code_as_wasm","include_code","raw","wast","wasm","code_hash","get_currency_balance","account","symbol","balances","map","balance","toFixed","get_currency_stats","currencies","contract","stats","_a","supply","max_supply","issuer","get_info","get_producer_schedule","get_producers","json","lower_bound","get_raw_code_and_abi","getRawAbi","accountName","rawCodeAndAbi","sent","groups","group","digit0","digit1","digit2","digit3","base64ToBinary","get_table_rows","_b","scope","table","_d","table_key","_e","upper_bound","_f","binary","getRequiredKeys","transaction","available_keys","availableKeys","required_keys","push_transaction","signatures","serializedTransaction","tx","packed_trx","transaction_id","tx_id","db_size_get","history_get_actions","pos","history_get_transaction","block_num_hint","history_get_key_accounts","public_key","account_names","accounts","history_get_controlled_accounts","controlling_account","Axios","createInstance","defaultConfig","context","instance","axios","instanceConfig","CancelToken","isCancel","all","promises","spread","default","constructor","readFloatLE","isSlowBuffer","_isBuffer","InterceptorManager","dispatchRequest","interceptors","chain","interceptor","unshift","fulfilled","rejected","shift","normalizedName","encodeURIComponent","serializedParams","v","toISOString","ignoreDuplicateOf","parsed","split","line","originURL","msie","userAgent","urlParsingNode","createElement","resolveURL","href","setAttribute","protocol","host","search","hostname","port","pathname","location","requestURL","E","input","output","idx","write","expires","path","domain","secure","cookie","Date","toGMTString","match","RegExp","decodeURIComponent","remove","now","handlers","use","eject","h","transformData","isAbsoluteURL","combineURLs","throwIfCancellationRequested","throwIfRequested","reason","fns","relativeURL","executor","resolvePromise","token","callback","arr","isLong","__isLong__","INT_CACHE","UINT_CACHE","fromInt","cachedObj","cache","UZERO","ZERO","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","MIN_VALUE","MAX_VALUE","neg","TWO_PWR_32_DBL","lowBits","highBits","pow_dbl","radix","radixToPower","min","power","mul","add","fromValue","TWO_PWR_16_DBL","TWO_PWR_24","UONE","NEG_ONE","LongPrototype","toNumber","isZero","isNegative","eq","radixLong","div","rem1","sub","rem","remDiv","digits","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","isPositive","isOdd","isEven","equals","other","notEquals","neq","lessThan","comp","lt","lessThanOrEqual","lte","greaterThan","gt","greaterThanOrEqual","gte","compare","thisNeg","otherNeg","not","addend","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","subtract","subtrahend","multiply","multiplier","b00","divide","divisor","approx","res","shru","shr","shl","max","log2","ceil","delta","approxRes","approxRem","modulo","mod","or","numBits","toBytes","le","toBytesLE","toBytesBE","[object Object]","message_size","n_pad","get_n_pad_bytes","msg_bit_size_most","msg_bit_size_least","dividend","divmod","index","padded","data_view","DataView","setUint8","setUint32","y","z","from","reduce","count","pad","rP","sP","X","_","Proxy","block_view","getUint32","A","B","C","D","AP","BP","CP","DP","EP","T","add_modulo32","rol32","f","K","KP","h_i"],"mappings":"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","file":"cowjs-eosjs-jsonrpc.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 78);\n","'use strict';\n\nvar bind = require('./helpers/bind');\nvar isBuffer = require('is-buffer');\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim\n};\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*\r\n Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>\r\n\r\n Licensed under the Apache License, Version 2.0 (the \"License\");\r\n you may not use this file except in compliance with the License.\r\n You may obtain a copy of the License at\r\n\r\n http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n Unless required by applicable law or agreed to in writing, software\r\n distributed under the License is distributed on an \"AS IS\" BASIS,\r\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n See the License for the specific language governing permissions and\r\n limitations under the License.\r\n */\r\n\r\n/**\r\n * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>\r\n * Backing buffer: ArrayBuffer, Accessor: Uint8Array\r\n * Released under the Apache License, Version 2.0\r\n * see: https://github.com/dcodeIO/bytebuffer.js for details\r\n */\r\n(function(global, factory) {\r\n\r\n    /* AMD */ if (typeof define === 'function' && define[\"amd\"])\r\n        define([\"long\"], factory);\r\n    /* CommonJS */ else if (typeof require === 'function' && typeof module === \"object\" && module && module[\"exports\"])\r\n        module['exports'] = (function() {\r\n            var Long; try { Long = require(\"long\"); } catch (e) {}\r\n            return factory(Long);\r\n        })();\r\n    /* Global */ else\r\n        (global[\"dcodeIO\"] = global[\"dcodeIO\"] || {})[\"ByteBuffer\"] = factory(global[\"dcodeIO\"][\"Long\"]);\r\n\r\n})(this, function(Long) {\r\n    \"use strict\";\r\n\r\n    /**\r\n     * Constructs a new ByteBuffer.\r\n     * @class The swiss army knife for binary data in JavaScript.\r\n     * @exports ByteBuffer\r\n     * @constructor\r\n     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_NOASSERT}.\r\n     * @expose\r\n     */\r\n    var ByteBuffer = function(capacity, littleEndian, noAssert) {\r\n        if (typeof capacity === 'undefined')\r\n            capacity = ByteBuffer.DEFAULT_CAPACITY;\r\n        if (typeof littleEndian === 'undefined')\r\n            littleEndian = ByteBuffer.DEFAULT_ENDIAN;\r\n        if (typeof noAssert === 'undefined')\r\n            noAssert = ByteBuffer.DEFAULT_NOASSERT;\r\n        if (!noAssert) {\r\n            capacity = capacity | 0;\r\n            if (capacity < 0)\r\n                throw RangeError(\"Illegal capacity\");\r\n            littleEndian = !!littleEndian;\r\n            noAssert = !!noAssert;\r\n        }\r\n\r\n        /**\r\n         * Backing ArrayBuffer.\r\n         * @type {!ArrayBuffer}\r\n         * @expose\r\n         */\r\n        this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity);\r\n\r\n        /**\r\n         * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.\r\n         * @type {?Uint8Array}\r\n         * @expose\r\n         */\r\n        this.view = capacity === 0 ? null : new Uint8Array(this.buffer);\r\n\r\n        /**\r\n         * Absolute read/write offset.\r\n         * @type {number}\r\n         * @expose\r\n         * @see ByteBuffer#flip\r\n         * @see ByteBuffer#clear\r\n         */\r\n        this.offset = 0;\r\n\r\n        /**\r\n         * Marked offset.\r\n         * @type {number}\r\n         * @expose\r\n         * @see ByteBuffer#mark\r\n         * @see ByteBuffer#reset\r\n         */\r\n        this.markedOffset = -1;\r\n\r\n        /**\r\n         * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.\r\n         * @type {number}\r\n         * @expose\r\n         * @see ByteBuffer#flip\r\n         * @see ByteBuffer#clear\r\n         */\r\n        this.limit = capacity;\r\n\r\n        /**\r\n         * Whether to use little endian byte order, defaults to `false` for big endian.\r\n         * @type {boolean}\r\n         * @expose\r\n         */\r\n        this.littleEndian = littleEndian;\r\n\r\n        /**\r\n         * Whether to skip assertions of offsets and values, defaults to `false`.\r\n         * @type {boolean}\r\n         * @expose\r\n         */\r\n        this.noAssert = noAssert;\r\n    };\r\n\r\n    /**\r\n     * ByteBuffer version.\r\n     * @type {string}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ByteBuffer.VERSION = \"5.0.1\";\r\n\r\n    /**\r\n     * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.\r\n     * @type {boolean}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ByteBuffer.LITTLE_ENDIAN = true;\r\n\r\n    /**\r\n     * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.\r\n     * @type {boolean}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ByteBuffer.BIG_ENDIAN = false;\r\n\r\n    /**\r\n     * Default initial capacity of `16`.\r\n     * @type {number}\r\n     * @expose\r\n     */\r\n    ByteBuffer.DEFAULT_CAPACITY = 16;\r\n\r\n    /**\r\n     * Default endianess of `false` for big endian.\r\n     * @type {boolean}\r\n     * @expose\r\n     */\r\n    ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;\r\n\r\n    /**\r\n     * Default no assertions flag of `false`.\r\n     * @type {boolean}\r\n     * @expose\r\n     */\r\n    ByteBuffer.DEFAULT_NOASSERT = false;\r\n\r\n    /**\r\n     * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded\r\n     *  and int64 support is not available.\r\n     * @type {?Long}\r\n     * @const\r\n     * @see https://github.com/dcodeIO/long.js\r\n     * @expose\r\n     */\r\n    ByteBuffer.Long = Long || null;\r\n\r\n    /**\r\n     * @alias ByteBuffer.prototype\r\n     * @inner\r\n     */\r\n    var ByteBufferPrototype = ByteBuffer.prototype;\r\n\r\n    /**\r\n     * An indicator used to reliably determine if an object is a ByteBuffer or not.\r\n     * @type {boolean}\r\n     * @const\r\n     * @expose\r\n     * @private\r\n     */\r\n    ByteBufferPrototype.__isByteBuffer__;\r\n\r\n    Object.defineProperty(ByteBufferPrototype, \"__isByteBuffer__\", {\r\n        value: true,\r\n        enumerable: false,\r\n        configurable: false\r\n    });\r\n\r\n    // helpers\r\n\r\n    /**\r\n     * @type {!ArrayBuffer}\r\n     * @inner\r\n     */\r\n    var EMPTY_BUFFER = new ArrayBuffer(0);\r\n\r\n    /**\r\n     * String.fromCharCode reference for compile-time renaming.\r\n     * @type {function(...number):string}\r\n     * @inner\r\n     */\r\n    var stringFromCharCode = String.fromCharCode;\r\n\r\n    /**\r\n     * Creates a source function for a string.\r\n     * @param {string} s String to read from\r\n     * @returns {function():number|null} Source function returning the next char code respectively `null` if there are\r\n     *  no more characters left.\r\n     * @throws {TypeError} If the argument is invalid\r\n     * @inner\r\n     */\r\n    function stringSource(s) {\r\n        var i=0; return function() {\r\n            return i < s.length ? s.charCodeAt(i++) : null;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates a destination function for a string.\r\n     * @returns {function(number=):undefined|string} Destination function successively called with the next char code.\r\n     *  Returns the final string when called without arguments.\r\n     * @inner\r\n     */\r\n    function stringDestination() {\r\n        var cs = [], ps = []; return function() {\r\n            if (arguments.length === 0)\r\n                return ps.join('')+stringFromCharCode.apply(String, cs);\r\n            if (cs.length + arguments.length > 1024)\r\n                ps.push(stringFromCharCode.apply(String, cs)),\r\n                    cs.length = 0;\r\n            Array.prototype.push.apply(cs, arguments);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the accessor type.\r\n     * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)\r\n     * @expose\r\n     */\r\n    ByteBuffer.accessor = function() {\r\n        return Uint8Array;\r\n    };\r\n    /**\r\n     * Allocates a new ByteBuffer backed by a buffer of the specified capacity.\r\n     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_NOASSERT}.\r\n     * @returns {!ByteBuffer}\r\n     * @expose\r\n     */\r\n    ByteBuffer.allocate = function(capacity, littleEndian, noAssert) {\r\n        return new ByteBuffer(capacity, littleEndian, noAssert);\r\n    };\r\n\r\n    /**\r\n     * Concatenates multiple ByteBuffers into one.\r\n     * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate\r\n     * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string (\"base64\", \"hex\", \"binary\",\r\n     *  defaults to \"utf8\")\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults\r\n     *  to {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_NOASSERT}.\r\n     * @returns {!ByteBuffer} Concatenated ByteBuffer\r\n     * @expose\r\n     */\r\n    ByteBuffer.concat = function(buffers, encoding, littleEndian, noAssert) {\r\n        if (typeof encoding === 'boolean' || typeof encoding !== 'string') {\r\n            noAssert = littleEndian;\r\n            littleEndian = encoding;\r\n            encoding = undefined;\r\n        }\r\n        var capacity = 0;\r\n        for (var i=0, k=buffers.length, length; i<k; ++i) {\r\n            if (!ByteBuffer.isByteBuffer(buffers[i]))\r\n                buffers[i] = ByteBuffer.wrap(buffers[i], encoding);\r\n            length = buffers[i].limit - buffers[i].offset;\r\n            if (length > 0) capacity += length;\r\n        }\r\n        if (capacity === 0)\r\n            return new ByteBuffer(0, littleEndian, noAssert);\r\n        var bb = new ByteBuffer(capacity, littleEndian, noAssert),\r\n            bi;\r\n        i=0; while (i<k) {\r\n            bi = buffers[i++];\r\n            length = bi.limit - bi.offset;\r\n            if (length <= 0) continue;\r\n            bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset);\r\n            bb.offset += length;\r\n        }\r\n        bb.limit = bb.offset;\r\n        bb.offset = 0;\r\n        return bb;\r\n    };\r\n\r\n    /**\r\n     * Tests if the specified type is a ByteBuffer.\r\n     * @param {*} bb ByteBuffer to test\r\n     * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`\r\n     * @expose\r\n     */\r\n    ByteBuffer.isByteBuffer = function(bb) {\r\n        return (bb && bb[\"__isByteBuffer__\"]) === true;\r\n    };\r\n    /**\r\n     * Gets the backing buffer type.\r\n     * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)\r\n     * @expose\r\n     */\r\n    ByteBuffer.type = function() {\r\n        return ArrayBuffer;\r\n    };\r\n    /**\r\n     * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its\r\n     *  {@link ByteBuffer#limit} to the length of the wrapped data.\r\n     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped\r\n     * @param {(string|boolean)=} encoding String encoding if `buffer` is a string (\"base64\", \"hex\", \"binary\", defaults to\r\n     *  \"utf8\")\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_NOASSERT}.\r\n     * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`\r\n     * @expose\r\n     */\r\n    ByteBuffer.wrap = function(buffer, encoding, littleEndian, noAssert) {\r\n        if (typeof encoding !== 'string') {\r\n            noAssert = littleEndian;\r\n            littleEndian = encoding;\r\n            encoding = undefined;\r\n        }\r\n        if (typeof buffer === 'string') {\r\n            if (typeof encoding === 'undefined')\r\n                encoding = \"utf8\";\r\n            switch (encoding) {\r\n                case \"base64\":\r\n                    return ByteBuffer.fromBase64(buffer, littleEndian);\r\n                case \"hex\":\r\n                    return ByteBuffer.fromHex(buffer, littleEndian);\r\n                case \"binary\":\r\n                    return ByteBuffer.fromBinary(buffer, littleEndian);\r\n                case \"utf8\":\r\n                    return ByteBuffer.fromUTF8(buffer, littleEndian);\r\n                case \"debug\":\r\n                    return ByteBuffer.fromDebug(buffer, littleEndian);\r\n                default:\r\n                    throw Error(\"Unsupported encoding: \"+encoding);\r\n            }\r\n        }\r\n        if (buffer === null || typeof buffer !== 'object')\r\n            throw TypeError(\"Illegal buffer\");\r\n        var bb;\r\n        if (ByteBuffer.isByteBuffer(buffer)) {\r\n            bb = ByteBufferPrototype.clone.call(buffer);\r\n            bb.markedOffset = -1;\r\n            return bb;\r\n        }\r\n        if (buffer instanceof Uint8Array) { // Extract ArrayBuffer from Uint8Array\r\n            bb = new ByteBuffer(0, littleEndian, noAssert);\r\n            if (buffer.length > 0) { // Avoid references to more than one EMPTY_BUFFER\r\n                bb.buffer = buffer.buffer;\r\n                bb.offset = buffer.byteOffset;\r\n                bb.limit = buffer.byteOffset + buffer.byteLength;\r\n                bb.view = new Uint8Array(buffer.buffer);\r\n            }\r\n        } else if (buffer instanceof ArrayBuffer) { // Reuse ArrayBuffer\r\n            bb = new ByteBuffer(0, littleEndian, noAssert);\r\n            if (buffer.byteLength > 0) {\r\n                bb.buffer = buffer;\r\n                bb.offset = 0;\r\n                bb.limit = buffer.byteLength;\r\n                bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;\r\n            }\r\n        } else if (Object.prototype.toString.call(buffer) === \"[object Array]\") { // Create from octets\r\n            bb = new ByteBuffer(buffer.length, littleEndian, noAssert);\r\n            bb.limit = buffer.length;\r\n            for (var i=0; i<buffer.length; ++i)\r\n                bb.view[i] = buffer[i];\r\n        } else\r\n            throw TypeError(\"Illegal buffer\"); // Otherwise fail\r\n        return bb;\r\n    };\r\n\r\n    /**\r\n     * Writes the array as a bitset.\r\n     * @param {Array<boolean>} value Array of booleans to write\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.\r\n     * @returns {!ByteBuffer}\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeBitSet = function(value, offset) {\r\n      var relative = typeof offset === 'undefined';\n      if (relative) offset = this.offset;\n      if (!this.noAssert) {\r\n        if (!(value instanceof Array))\r\n          throw TypeError(\"Illegal BitSet: Not an array\");\r\n        if (typeof offset !== 'number' || offset % 1 !== 0)\n            throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n        offset >>>= 0;\n        if (offset < 0 || offset + 0 > this.buffer.byteLength)\n            throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n      }\r\n\r\n      var start = offset,\r\n          bits = value.length,\r\n          bytes = (bits >> 3),\r\n          bit = 0,\r\n          k;\r\n\r\n      offset += this.writeVarint32(bits,offset);\r\n\r\n      while(bytes--) {\r\n        k = (!!value[bit++] & 1) |\r\n            ((!!value[bit++] & 1) << 1) |\r\n            ((!!value[bit++] & 1) << 2) |\r\n            ((!!value[bit++] & 1) << 3) |\r\n            ((!!value[bit++] & 1) << 4) |\r\n            ((!!value[bit++] & 1) << 5) |\r\n            ((!!value[bit++] & 1) << 6) |\r\n            ((!!value[bit++] & 1) << 7);\r\n        this.writeByte(k,offset++);\r\n      }\r\n\r\n      if(bit < bits) {\r\n        var m = 0; k = 0;\r\n        while(bit < bits) k = k | ((!!value[bit++] & 1) << (m++));\r\n        this.writeByte(k,offset++);\r\n      }\r\n\r\n      if (relative) {\r\n        this.offset = offset;\r\n        return this;\r\n      }\r\n      return offset - start;\r\n    }\r\n\r\n    /**\r\n     * Reads a BitSet as an array of booleans.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.\r\n     * @returns {Array<boolean>\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readBitSet = function(offset) {\r\n      var relative = typeof offset === 'undefined';\n      if (relative) offset = this.offset;\n\r\n      var ret = this.readVarint32(offset),\r\n          bits = ret.value,\r\n          bytes = (bits >> 3),\r\n          bit = 0,\r\n          value = [],\r\n          k;\r\n\r\n      offset += ret.length;\r\n\r\n      while(bytes--) {\r\n        k = this.readByte(offset++);\r\n        value[bit++] = !!(k & 0x01);\r\n        value[bit++] = !!(k & 0x02);\r\n        value[bit++] = !!(k & 0x04);\r\n        value[bit++] = !!(k & 0x08);\r\n        value[bit++] = !!(k & 0x10);\r\n        value[bit++] = !!(k & 0x20);\r\n        value[bit++] = !!(k & 0x40);\r\n        value[bit++] = !!(k & 0x80);\r\n      }\r\n\r\n      if(bit < bits) {\r\n        var m = 0;\r\n        k = this.readByte(offset++);\r\n        while(bit < bits) value[bit++] = !!((k >> (m++)) & 1);\r\n      }\r\n\r\n      if (relative) {\r\n        this.offset = offset;\r\n      }\r\n      return value;\r\n    }\r\n    /**\r\n     * Reads the specified number of bytes.\r\n     * @param {number} length Number of bytes to read\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.\r\n     * @returns {!ByteBuffer}\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readBytes = function(length, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + length > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+length+\") <= \"+this.buffer.byteLength);\n        }\r\n        var slice = this.slice(offset, offset + length);\r\n        if (relative) this.offset += length;\n        return slice;\r\n    };\r\n\r\n    /**\r\n     * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.\r\n     * @function\r\n     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets\r\n     *  will be modified according to the performed read operation.\r\n     * @param {(string|number)=} encoding Encoding if `data` is a string (\"base64\", \"hex\", \"binary\", defaults to \"utf8\")\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeBytes = ByteBufferPrototype.append;\r\n\r\n    // types/ints/int8\r\n\r\n    /**\r\n     * Writes an 8bit signed integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeInt8 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value |= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 1;\n        var capacity0 = this.buffer.byteLength;\n        if (offset > capacity0)\n            this.resize((capacity0 *= 2) > offset ? capacity0 : offset);\n        offset -= 1;\n        this.view[offset] = value;\r\n        if (relative) this.offset += 1;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.\r\n     * @function\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;\r\n\r\n    /**\r\n     * Reads an 8bit signed integer.\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readInt8 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 1 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+1+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = this.view[offset];\r\n        if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed\r\n        if (relative) this.offset += 1;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.\r\n     * @function\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;\r\n\r\n    /**\r\n     * Writes an 8bit unsigned integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeUint8 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value >>>= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 1;\n        var capacity1 = this.buffer.byteLength;\n        if (offset > capacity1)\n            this.resize((capacity1 *= 2) > offset ? capacity1 : offset);\n        offset -= 1;\n        this.view[offset] = value;\r\n        if (relative) this.offset += 1;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.\r\n     * @function\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;\r\n\r\n    /**\r\n     * Reads an 8bit unsigned integer.\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readUint8 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 1 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+1+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = this.view[offset];\r\n        if (relative) this.offset += 1;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.\r\n     * @function\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8;\r\n\r\n    // types/ints/int16\r\n\r\n    /**\r\n     * Writes a 16bit signed integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @throws {TypeError} If `offset` or `value` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeInt16 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value |= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 2;\n        var capacity2 = this.buffer.byteLength;\n        if (offset > capacity2)\n            this.resize((capacity2 *= 2) > offset ? capacity2 : offset);\n        offset -= 2;\n        if (this.littleEndian) {\r\n            this.view[offset+1] = (value & 0xFF00) >>> 8;\r\n            this.view[offset  ] =  value & 0x00FF;\r\n        } else {\r\n            this.view[offset]   = (value & 0xFF00) >>> 8;\r\n            this.view[offset+1] =  value & 0x00FF;\r\n        }\r\n        if (relative) this.offset += 2;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.\r\n     * @function\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @throws {TypeError} If `offset` or `value` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;\r\n\r\n    /**\r\n     * Reads a 16bit signed integer.\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @returns {number} Value read\r\n     * @throws {TypeError} If `offset` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readInt16 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 2 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+2+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = 0;\r\n        if (this.littleEndian) {\r\n            value  = this.view[offset  ];\r\n            value |= this.view[offset+1] << 8;\r\n        } else {\r\n            value  = this.view[offset  ] << 8;\r\n            value |= this.view[offset+1];\r\n        }\r\n        if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed\r\n        if (relative) this.offset += 2;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.\r\n     * @function\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @returns {number} Value read\r\n     * @throws {TypeError} If `offset` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;\r\n\r\n    /**\r\n     * Writes a 16bit unsigned integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @throws {TypeError} If `offset` or `value` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeUint16 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value >>>= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 2;\n        var capacity3 = this.buffer.byteLength;\n        if (offset > capacity3)\n            this.resize((capacity3 *= 2) > offset ? capacity3 : offset);\n        offset -= 2;\n        if (this.littleEndian) {\r\n            this.view[offset+1] = (value & 0xFF00) >>> 8;\r\n            this.view[offset  ] =  value & 0x00FF;\r\n        } else {\r\n            this.view[offset]   = (value & 0xFF00) >>> 8;\r\n            this.view[offset+1] =  value & 0x00FF;\r\n        }\r\n        if (relative) this.offset += 2;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.\r\n     * @function\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @throws {TypeError} If `offset` or `value` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;\r\n\r\n    /**\r\n     * Reads a 16bit unsigned integer.\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @returns {number} Value read\r\n     * @throws {TypeError} If `offset` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readUint16 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 2 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+2+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = 0;\r\n        if (this.littleEndian) {\r\n            value  = this.view[offset  ];\r\n            value |= this.view[offset+1] << 8;\r\n        } else {\r\n            value  = this.view[offset  ] << 8;\r\n            value |= this.view[offset+1];\r\n        }\r\n        if (relative) this.offset += 2;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.\r\n     * @function\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @returns {number} Value read\r\n     * @throws {TypeError} If `offset` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16;\r\n\r\n    // types/ints/int32\r\n\r\n    /**\r\n     * Writes a 32bit signed integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeInt32 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value |= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 4;\n        var capacity4 = this.buffer.byteLength;\n        if (offset > capacity4)\n            this.resize((capacity4 *= 2) > offset ? capacity4 : offset);\n        offset -= 4;\n        if (this.littleEndian) {\n            this.view[offset+3] = (value >>> 24) & 0xFF;\n            this.view[offset+2] = (value >>> 16) & 0xFF;\n            this.view[offset+1] = (value >>>  8) & 0xFF;\n            this.view[offset  ] =  value         & 0xFF;\n        } else {\n            this.view[offset  ] = (value >>> 24) & 0xFF;\n            this.view[offset+1] = (value >>> 16) & 0xFF;\n            this.view[offset+2] = (value >>>  8) & 0xFF;\n            this.view[offset+3] =  value         & 0xFF;\n        }\n        if (relative) this.offset += 4;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;\r\n\r\n    /**\r\n     * Reads a 32bit signed integer.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readInt32 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 4 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+4+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = 0;\r\n        if (this.littleEndian) {\n            value  = this.view[offset+2] << 16;\n            value |= this.view[offset+1] <<  8;\n            value |= this.view[offset  ];\n            value += this.view[offset+3] << 24 >>> 0;\n        } else {\n            value  = this.view[offset+1] << 16;\n            value |= this.view[offset+2] <<  8;\n            value |= this.view[offset+3];\n            value += this.view[offset  ] << 24 >>> 0;\n        }\n        value |= 0; // Cast to signed\r\n        if (relative) this.offset += 4;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;\r\n\r\n    /**\r\n     * Writes a 32bit unsigned integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeUint32 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value >>>= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 4;\n        var capacity5 = this.buffer.byteLength;\n        if (offset > capacity5)\n            this.resize((capacity5 *= 2) > offset ? capacity5 : offset);\n        offset -= 4;\n        if (this.littleEndian) {\n            this.view[offset+3] = (value >>> 24) & 0xFF;\n            this.view[offset+2] = (value >>> 16) & 0xFF;\n            this.view[offset+1] = (value >>>  8) & 0xFF;\n            this.view[offset  ] =  value         & 0xFF;\n        } else {\n            this.view[offset  ] = (value >>> 24) & 0xFF;\n            this.view[offset+1] = (value >>> 16) & 0xFF;\n            this.view[offset+2] = (value >>>  8) & 0xFF;\n            this.view[offset+3] =  value         & 0xFF;\n        }\n        if (relative) this.offset += 4;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.\r\n     * @function\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;\r\n\r\n    /**\r\n     * Reads a 32bit unsigned integer.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readUint32 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 4 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+4+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = 0;\r\n        if (this.littleEndian) {\n            value  = this.view[offset+2] << 16;\n            value |= this.view[offset+1] <<  8;\n            value |= this.view[offset  ];\n            value += this.view[offset+3] << 24 >>> 0;\n        } else {\n            value  = this.view[offset+1] << 16;\n            value |= this.view[offset+2] <<  8;\n            value |= this.view[offset+3];\n            value += this.view[offset  ] << 24 >>> 0;\n        }\n        if (relative) this.offset += 4;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.\r\n     * @function\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32;\r\n\r\n    // types/ints/int64\r\n\r\n    if (Long) {\r\n\r\n        /**\r\n         * Writes a 64bit signed integer.\r\n         * @param {number|!Long} value Value to write\r\n         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!ByteBuffer} this\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.writeInt64 = function(value, offset) {\r\n            var relative = typeof offset === 'undefined';\n            if (relative) offset = this.offset;\n            if (!this.noAssert) {\r\n                if (typeof value === 'number')\n                    value = Long.fromNumber(value);\n                else if (typeof value === 'string')\n                    value = Long.fromString(value);\n                else if (!(value && value instanceof Long))\n                    throw TypeError(\"Illegal value: \"+value+\" (not an integer or Long)\");\n                if (typeof offset !== 'number' || offset % 1 !== 0)\n                    throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n                offset >>>= 0;\n                if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                    throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n            }\r\n            if (typeof value === 'number')\n                value = Long.fromNumber(value);\n            else if (typeof value === 'string')\n                value = Long.fromString(value);\n            offset += 8;\n            var capacity6 = this.buffer.byteLength;\n            if (offset > capacity6)\n                this.resize((capacity6 *= 2) > offset ? capacity6 : offset);\n            offset -= 8;\n            var lo = value.low,\r\n                hi = value.high;\r\n            if (this.littleEndian) {\r\n                this.view[offset+3] = (lo >>> 24) & 0xFF;\n                this.view[offset+2] = (lo >>> 16) & 0xFF;\n                this.view[offset+1] = (lo >>>  8) & 0xFF;\n                this.view[offset  ] =  lo         & 0xFF;\n                offset += 4;\r\n                this.view[offset+3] = (hi >>> 24) & 0xFF;\n                this.view[offset+2] = (hi >>> 16) & 0xFF;\n                this.view[offset+1] = (hi >>>  8) & 0xFF;\n                this.view[offset  ] =  hi         & 0xFF;\n            } else {\r\n                this.view[offset  ] = (hi >>> 24) & 0xFF;\n                this.view[offset+1] = (hi >>> 16) & 0xFF;\n                this.view[offset+2] = (hi >>>  8) & 0xFF;\n                this.view[offset+3] =  hi         & 0xFF;\n                offset += 4;\r\n                this.view[offset  ] = (lo >>> 24) & 0xFF;\n                this.view[offset+1] = (lo >>> 16) & 0xFF;\n                this.view[offset+2] = (lo >>>  8) & 0xFF;\n                this.view[offset+3] =  lo         & 0xFF;\n            }\r\n            if (relative) this.offset += 8;\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.\r\n         * @param {number|!Long} value Value to write\r\n         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!ByteBuffer} this\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;\r\n\r\n        /**\r\n         * Reads a 64bit signed integer.\r\n         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!Long}\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.readInt64 = function(offset) {\r\n            var relative = typeof offset === 'undefined';\n            if (relative) offset = this.offset;\n            if (!this.noAssert) {\r\n                if (typeof offset !== 'number' || offset % 1 !== 0)\n                    throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n                offset >>>= 0;\n                if (offset < 0 || offset + 8 > this.buffer.byteLength)\n                    throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+8+\") <= \"+this.buffer.byteLength);\n            }\r\n            var lo = 0,\r\n                hi = 0;\r\n            if (this.littleEndian) {\r\n                lo  = this.view[offset+2] << 16;\n                lo |= this.view[offset+1] <<  8;\n                lo |= this.view[offset  ];\n                lo += this.view[offset+3] << 24 >>> 0;\n                offset += 4;\r\n                hi  = this.view[offset+2] << 16;\n                hi |= this.view[offset+1] <<  8;\n                hi |= this.view[offset  ];\n                hi += this.view[offset+3] << 24 >>> 0;\n            } else {\r\n                hi  = this.view[offset+1] << 16;\n                hi |= this.view[offset+2] <<  8;\n                hi |= this.view[offset+3];\n                hi += this.view[offset  ] << 24 >>> 0;\n                offset += 4;\r\n                lo  = this.view[offset+1] << 16;\n                lo |= this.view[offset+2] <<  8;\n                lo |= this.view[offset+3];\n                lo += this.view[offset  ] << 24 >>> 0;\n            }\r\n            var value = new Long(lo, hi, false);\r\n            if (relative) this.offset += 8;\n            return value;\r\n        };\r\n\r\n        /**\r\n         * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.\r\n         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!Long}\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;\r\n\r\n        /**\r\n         * Writes a 64bit unsigned integer.\r\n         * @param {number|!Long} value Value to write\r\n         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!ByteBuffer} this\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.writeUint64 = function(value, offset) {\r\n            var relative = typeof offset === 'undefined';\n            if (relative) offset = this.offset;\n            if (!this.noAssert) {\r\n                if (typeof value === 'number')\n                    value = Long.fromNumber(value);\n                else if (typeof value === 'string')\n                    value = Long.fromString(value);\n                else if (!(value && value instanceof Long))\n                    throw TypeError(\"Illegal value: \"+value+\" (not an integer or Long)\");\n                if (typeof offset !== 'number' || offset % 1 !== 0)\n                    throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n                offset >>>= 0;\n                if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                    throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n            }\r\n            if (typeof value === 'number')\n                value = Long.fromNumber(value);\n            else if (typeof value === 'string')\n                value = Long.fromString(value);\n            offset += 8;\n            var capacity7 = this.buffer.byteLength;\n            if (offset > capacity7)\n                this.resize((capacity7 *= 2) > offset ? capacity7 : offset);\n            offset -= 8;\n            var lo = value.low,\r\n                hi = value.high;\r\n            if (this.littleEndian) {\r\n                this.view[offset+3] = (lo >>> 24) & 0xFF;\n                this.view[offset+2] = (lo >>> 16) & 0xFF;\n                this.view[offset+1] = (lo >>>  8) & 0xFF;\n                this.view[offset  ] =  lo         & 0xFF;\n                offset += 4;\r\n                this.view[offset+3] = (hi >>> 24) & 0xFF;\n                this.view[offset+2] = (hi >>> 16) & 0xFF;\n                this.view[offset+1] = (hi >>>  8) & 0xFF;\n                this.view[offset  ] =  hi         & 0xFF;\n            } else {\r\n                this.view[offset  ] = (hi >>> 24) & 0xFF;\n                this.view[offset+1] = (hi >>> 16) & 0xFF;\n                this.view[offset+2] = (hi >>>  8) & 0xFF;\n                this.view[offset+3] =  hi         & 0xFF;\n                offset += 4;\r\n                this.view[offset  ] = (lo >>> 24) & 0xFF;\n                this.view[offset+1] = (lo >>> 16) & 0xFF;\n                this.view[offset+2] = (lo >>>  8) & 0xFF;\n                this.view[offset+3] =  lo         & 0xFF;\n            }\r\n            if (relative) this.offset += 8;\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.\r\n         * @function\r\n         * @param {number|!Long} value Value to write\r\n         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!ByteBuffer} this\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;\r\n\r\n        /**\r\n         * Reads a 64bit unsigned integer.\r\n         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!Long}\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.readUint64 = function(offset) {\r\n            var relative = typeof offset === 'undefined';\n            if (relative) offset = this.offset;\n            if (!this.noAssert) {\r\n                if (typeof offset !== 'number' || offset % 1 !== 0)\n                    throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n                offset >>>= 0;\n                if (offset < 0 || offset + 8 > this.buffer.byteLength)\n                    throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+8+\") <= \"+this.buffer.byteLength);\n            }\r\n            var lo = 0,\r\n                hi = 0;\r\n            if (this.littleEndian) {\r\n                lo  = this.view[offset+2] << 16;\n                lo |= this.view[offset+1] <<  8;\n                lo |= this.view[offset  ];\n                lo += this.view[offset+3] << 24 >>> 0;\n                offset += 4;\r\n                hi  = this.view[offset+2] << 16;\n                hi |= this.view[offset+1] <<  8;\n                hi |= this.view[offset  ];\n                hi += this.view[offset+3] << 24 >>> 0;\n            } else {\r\n                hi  = this.view[offset+1] << 16;\n                hi |= this.view[offset+2] <<  8;\n                hi |= this.view[offset+3];\n                hi += this.view[offset  ] << 24 >>> 0;\n                offset += 4;\r\n                lo  = this.view[offset+1] << 16;\n                lo |= this.view[offset+2] <<  8;\n                lo |= this.view[offset+3];\n                lo += this.view[offset  ] << 24 >>> 0;\n            }\r\n            var value = new Long(lo, hi, true);\r\n            if (relative) this.offset += 8;\n            return value;\r\n        };\r\n\r\n        /**\r\n         * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.\r\n         * @function\r\n         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!Long}\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;\r\n\r\n    } // Long\r\n\r\n\r\n    // types/floats/float32\r\n\r\n    /*\r\n     ieee754 - https://github.com/feross/ieee754\r\n\r\n     The MIT License (MIT)\r\n\r\n     Copyright (c) Feross Aboukhadijeh\r\n\r\n     Permission is hereby granted, free of charge, to any person obtaining a copy\r\n     of this software and associated documentation files (the \"Software\"), to deal\r\n     in the Software without restriction, including without limitation the rights\r\n     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n     copies of the Software, and to permit persons to whom the Software is\r\n     furnished to do so, subject to the following conditions:\r\n\r\n     The above copyright notice and this permission notice shall be included in\r\n     all copies or substantial portions of the Software.\r\n\r\n     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n     THE SOFTWARE.\r\n    */\r\n\r\n    /**\r\n     * Reads an IEEE754 float from a byte array.\r\n     * @param {!Array} buffer\r\n     * @param {number} offset\r\n     * @param {boolean} isLE\r\n     * @param {number} mLen\r\n     * @param {number} nBytes\r\n     * @returns {number}\r\n     * @inner\r\n     */\r\n    function ieee754_read(buffer, offset, isLE, mLen, nBytes) {\r\n        var e, m,\r\n            eLen = nBytes * 8 - mLen - 1,\r\n            eMax = (1 << eLen) - 1,\r\n            eBias = eMax >> 1,\r\n            nBits = -7,\r\n            i = isLE ? (nBytes - 1) : 0,\r\n            d = isLE ? -1 : 1,\r\n            s = buffer[offset + i];\r\n\r\n        i += d;\r\n\r\n        e = s & ((1 << (-nBits)) - 1);\r\n        s >>= (-nBits);\r\n        nBits += eLen;\r\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n        m = e & ((1 << (-nBits)) - 1);\r\n        e >>= (-nBits);\r\n        nBits += mLen;\r\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n        if (e === 0) {\r\n            e = 1 - eBias;\r\n        } else if (e === eMax) {\r\n            return m ? NaN : ((s ? -1 : 1) * Infinity);\r\n        } else {\r\n            m = m + Math.pow(2, mLen);\r\n            e = e - eBias;\r\n        }\r\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\r\n    }\r\n\r\n    /**\r\n     * Writes an IEEE754 float to a byte array.\r\n     * @param {!Array} buffer\r\n     * @param {number} value\r\n     * @param {number} offset\r\n     * @param {boolean} isLE\r\n     * @param {number} mLen\r\n     * @param {number} nBytes\r\n     * @inner\r\n     */\r\n    function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) {\r\n        var e, m, c,\r\n            eLen = nBytes * 8 - mLen - 1,\r\n            eMax = (1 << eLen) - 1,\r\n            eBias = eMax >> 1,\r\n            rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\r\n            i = isLE ? 0 : (nBytes - 1),\r\n            d = isLE ? 1 : -1,\r\n            s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\r\n\r\n        value = Math.abs(value);\r\n\r\n        if (isNaN(value) || value === Infinity) {\r\n            m = isNaN(value) ? 1 : 0;\r\n            e = eMax;\r\n        } else {\r\n            e = Math.floor(Math.log(value) / Math.LN2);\r\n            if (value * (c = Math.pow(2, -e)) < 1) {\r\n                e--;\r\n                c *= 2;\r\n            }\r\n            if (e + eBias >= 1) {\r\n                value += rt / c;\r\n            } else {\r\n                value += rt * Math.pow(2, 1 - eBias);\r\n            }\r\n            if (value * c >= 2) {\r\n                e++;\r\n                c /= 2;\r\n            }\r\n\r\n            if (e + eBias >= eMax) {\r\n                m = 0;\r\n                e = eMax;\r\n            } else if (e + eBias >= 1) {\r\n                m = (value * c - 1) * Math.pow(2, mLen);\r\n                e = e + eBias;\r\n            } else {\r\n                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\r\n                e = 0;\r\n            }\r\n        }\r\n\r\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\r\n\r\n        e = (e << mLen) | m;\r\n        eLen += mLen;\r\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\r\n\r\n        buffer[offset + i - d] |= s * 128;\r\n    }\r\n\r\n    /**\r\n     * Writes a 32bit float.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeFloat32 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number')\r\n                throw TypeError(\"Illegal value: \"+value+\" (not a number)\");\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 4;\n        var capacity8 = this.buffer.byteLength;\n        if (offset > capacity8)\n            this.resize((capacity8 *= 2) > offset ? capacity8 : offset);\n        offset -= 4;\n        ieee754_write(this.view, value, offset, this.littleEndian, 23, 4);\r\n        if (relative) this.offset += 4;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.\r\n     * @function\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;\r\n\r\n    /**\r\n     * Reads a 32bit float.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {number}\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readFloat32 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 4 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+4+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4);\r\n        if (relative) this.offset += 4;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.\r\n     * @function\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {number}\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32;\r\n\r\n    // types/floats/float64\r\n\r\n    /**\r\n     * Writes a 64bit float.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeFloat64 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number')\r\n                throw TypeError(\"Illegal value: \"+value+\" (not a number)\");\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 8;\n        var capacity9 = this.buffer.byteLength;\n        if (offset > capacity9)\n            this.resize((capacity9 *= 2) > offset ? capacity9 : offset);\n        offset -= 8;\n        ieee754_write(this.view, value, offset, this.littleEndian, 52, 8);\r\n        if (relative) this.offset += 8;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.\r\n     * @function\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;\r\n\r\n    /**\r\n     * Reads a 64bit float.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n     * @returns {number}\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readFloat64 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 8 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+8+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8);\r\n        if (relative) this.offset += 8;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.\r\n     * @function\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n     * @returns {number}\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64;\r\n\r\n\r\n    // types/varints/varint32\r\n\r\n    /**\r\n     * Maximum number of bytes required to store a 32bit base 128 variable-length integer.\r\n     * @type {number}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ByteBuffer.MAX_VARINT32_BYTES = 5;\r\n\r\n    /**\r\n     * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.\r\n     * @param {number} value Value to encode\r\n     * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}\r\n     * @expose\r\n     */\r\n    ByteBuffer.calculateVarint32 = function(value) {\r\n        // ref: src/google/protobuf/io/coded_stream.cc\r\n        value = value >>> 0;\r\n             if (value < 1 << 7 ) return 1;\r\n        else if (value < 1 << 14) return 2;\r\n        else if (value < 1 << 21) return 3;\r\n        else if (value < 1 << 28) return 4;\r\n        else                      return 5;\r\n    };\r\n\r\n    /**\r\n     * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.\r\n     * @param {number} n Signed 32bit integer\r\n     * @returns {number} Unsigned zigzag encoded 32bit integer\r\n     * @expose\r\n     */\r\n    ByteBuffer.zigZagEncode32 = function(n) {\r\n        return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h\r\n    };\r\n\r\n    /**\r\n     * Decodes a zigzag encoded signed 32bit integer.\r\n     * @param {number} n Unsigned zigzag encoded 32bit integer\r\n     * @returns {number} Signed 32bit integer\r\n     * @expose\r\n     */\r\n    ByteBuffer.zigZagDecode32 = function(n) {\r\n        return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h\r\n    };\r\n\r\n    /**\r\n     * Writes a 32bit base 128 variable-length integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeVarint32 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value |= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        var size = ByteBuffer.calculateVarint32(value),\r\n            b;\r\n        offset += size;\n        var capacity10 = this.buffer.byteLength;\n        if (offset > capacity10)\n            this.resize((capacity10 *= 2) > offset ? capacity10 : offset);\n        offset -= size;\n        value >>>= 0;\r\n        while (value >= 0x80) {\r\n            b = (value & 0x7f) | 0x80;\r\n            this.view[offset++] = b;\r\n            value >>>= 7;\r\n        }\r\n        this.view[offset++] = value;\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return this;\r\n        }\r\n        return size;\r\n    };\r\n\r\n    /**\r\n     * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) {\r\n        return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);\r\n    };\r\n\r\n    /**\r\n     * Reads a 32bit base 128 variable-length integer.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read\r\n     *  and the actual number of bytes read.\r\n     * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available\r\n     *  to fully decode the varint.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readVarint32 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 1 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+1+\") <= \"+this.buffer.byteLength);\n        }\r\n        var c = 0,\r\n            value = 0 >>> 0,\r\n            b;\r\n        do {\r\n            if (!this.noAssert && offset > this.limit) {\r\n                var err = Error(\"Truncated\");\r\n                err['truncated'] = true;\r\n                throw err;\r\n            }\r\n            b = this.view[offset++];\r\n            if (c < 5)\r\n                value |= (b & 0x7f) << (7*c);\r\n            ++c;\r\n        } while ((b & 0x80) !== 0);\r\n        value |= 0;\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return value;\r\n        }\r\n        return {\r\n            \"value\": value,\r\n            \"length\": c\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read\r\n     *  and the actual number of bytes read.\r\n     * @throws {Error} If it's not a valid varint\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readVarint32ZigZag = function(offset) {\r\n        var val = this.readVarint32(offset);\r\n        if (typeof val === 'object')\r\n            val[\"value\"] = ByteBuffer.zigZagDecode32(val[\"value\"]);\r\n        else\r\n            val = ByteBuffer.zigZagDecode32(val);\r\n        return val;\r\n    };\r\n\r\n    // types/varints/varint64\r\n\r\n    if (Long) {\r\n\r\n        /**\r\n         * Maximum number of bytes required to store a 64bit base 128 variable-length integer.\r\n         * @type {number}\r\n         * @const\r\n         * @expose\r\n         */\r\n        ByteBuffer.MAX_VARINT64_BYTES = 10;\r\n\r\n        /**\r\n         * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.\r\n         * @param {number|!Long} value Value to encode\r\n         * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}\r\n         * @expose\r\n         */\r\n        ByteBuffer.calculateVarint64 = function(value) {\r\n            if (typeof value === 'number')\n                value = Long.fromNumber(value);\n            else if (typeof value === 'string')\n                value = Long.fromString(value);\n            // ref: src/google/protobuf/io/coded_stream.cc\r\n            var part0 = value.toInt() >>> 0,\r\n                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,\r\n                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;\r\n            if (part2 == 0) {\r\n                if (part1 == 0) {\r\n                    if (part0 < 1 << 14)\r\n                        return part0 < 1 << 7 ? 1 : 2;\r\n                    else\r\n                        return part0 < 1 << 21 ? 3 : 4;\r\n                } else {\r\n                    if (part1 < 1 << 14)\r\n                        return part1 < 1 << 7 ? 5 : 6;\r\n                    else\r\n                        return part1 < 1 << 21 ? 7 : 8;\r\n                }\r\n            } else\r\n                return part2 < 1 << 7 ? 9 : 10;\r\n        };\r\n\r\n        /**\r\n         * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.\r\n         * @param {number|!Long} value Signed long\r\n         * @returns {!Long} Unsigned zigzag encoded long\r\n         * @expose\r\n         */\r\n        ByteBuffer.zigZagEncode64 = function(value) {\r\n            if (typeof value === 'number')\n                value = Long.fromNumber(value, false);\n            else if (typeof value === 'string')\n                value = Long.fromString(value, false);\n            else if (value.unsigned !== false) value = value.toSigned();\n            // ref: src/google/protobuf/wire_format_lite.h\r\n            return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();\r\n        };\r\n\r\n        /**\r\n         * Decodes a zigzag encoded signed 64bit integer.\r\n         * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number\r\n         * @returns {!Long} Signed long\r\n         * @expose\r\n         */\r\n        ByteBuffer.zigZagDecode64 = function(value) {\r\n            if (typeof value === 'number')\n                value = Long.fromNumber(value, false);\n            else if (typeof value === 'string')\n                value = Long.fromString(value, false);\n            else if (value.unsigned !== false) value = value.toSigned();\n            // ref: src/google/protobuf/wire_format_lite.h\r\n            return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();\r\n        };\r\n\r\n        /**\r\n         * Writes a 64bit base 128 variable-length integer.\r\n         * @param {number|Long} value Value to write\r\n         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n         *  written if omitted.\r\n         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.writeVarint64 = function(value, offset) {\r\n            var relative = typeof offset === 'undefined';\n            if (relative) offset = this.offset;\n            if (!this.noAssert) {\r\n                if (typeof value === 'number')\n                    value = Long.fromNumber(value);\n                else if (typeof value === 'string')\n                    value = Long.fromString(value);\n                else if (!(value && value instanceof Long))\n                    throw TypeError(\"Illegal value: \"+value+\" (not an integer or Long)\");\n                if (typeof offset !== 'number' || offset % 1 !== 0)\n                    throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n                offset >>>= 0;\n                if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                    throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n            }\r\n            if (typeof value === 'number')\n                value = Long.fromNumber(value, false);\n            else if (typeof value === 'string')\n                value = Long.fromString(value, false);\n            else if (value.unsigned !== false) value = value.toSigned();\n            var size = ByteBuffer.calculateVarint64(value),\r\n                part0 = value.toInt() >>> 0,\r\n                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,\r\n                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;\r\n            offset += size;\n            var capacity11 = this.buffer.byteLength;\n            if (offset > capacity11)\n                this.resize((capacity11 *= 2) > offset ? capacity11 : offset);\n            offset -= size;\n            switch (size) {\r\n                case 10: this.view[offset+9] = (part2 >>>  7) & 0x01;\r\n                case 9 : this.view[offset+8] = size !== 9 ? (part2       ) | 0x80 : (part2       ) & 0x7F;\r\n                case 8 : this.view[offset+7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;\r\n                case 7 : this.view[offset+6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;\r\n                case 6 : this.view[offset+5] = size !== 6 ? (part1 >>>  7) | 0x80 : (part1 >>>  7) & 0x7F;\r\n                case 5 : this.view[offset+4] = size !== 5 ? (part1       ) | 0x80 : (part1       ) & 0x7F;\r\n                case 4 : this.view[offset+3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;\r\n                case 3 : this.view[offset+2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;\r\n                case 2 : this.view[offset+1] = size !== 2 ? (part0 >>>  7) | 0x80 : (part0 >>>  7) & 0x7F;\r\n                case 1 : this.view[offset  ] = size !== 1 ? (part0       ) | 0x80 : (part0       ) & 0x7F;\r\n            }\r\n            if (relative) {\r\n                this.offset += size;\r\n                return this;\r\n            } else {\r\n                return size;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Writes a zig-zag encoded 64bit base 128 variable-length integer.\r\n         * @param {number|Long} value Value to write\r\n         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n         *  written if omitted.\r\n         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) {\r\n            return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);\r\n        };\r\n\r\n        /**\r\n         * Reads a 64bit base 128 variable-length integer. Requires Long.js.\r\n         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n         *  read if omitted.\r\n         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and\r\n         *  the actual number of bytes read.\r\n         * @throws {Error} If it's not a valid varint\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.readVarint64 = function(offset) {\r\n            var relative = typeof offset === 'undefined';\n            if (relative) offset = this.offset;\n            if (!this.noAssert) {\r\n                if (typeof offset !== 'number' || offset % 1 !== 0)\n                    throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n                offset >>>= 0;\n                if (offset < 0 || offset + 1 > this.buffer.byteLength)\n                    throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+1+\") <= \"+this.buffer.byteLength);\n            }\r\n            // ref: src/google/protobuf/io/coded_stream.cc\r\n            var start = offset,\r\n                part0 = 0,\r\n                part1 = 0,\r\n                part2 = 0,\r\n                b  = 0;\r\n            b = this.view[offset++]; part0  = (b & 0x7F)      ; if ( b & 0x80                                                   ) {\r\n            b = this.view[offset++]; part0 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part0 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part0 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part1  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part1 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part1 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part1 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part2  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part2 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            throw Error(\"Buffer overrun\"); }}}}}}}}}}\r\n            var value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, false);\r\n            if (relative) {\r\n                this.offset = offset;\r\n                return value;\r\n            } else {\r\n                return {\r\n                    'value': value,\r\n                    'length': offset-start\r\n                };\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.\r\n         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n         *  read if omitted.\r\n         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and\r\n         *  the actual number of bytes read.\r\n         * @throws {Error} If it's not a valid varint\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.readVarint64ZigZag = function(offset) {\r\n            var val = this.readVarint64(offset);\r\n            if (val && val['value'] instanceof Long)\r\n                val[\"value\"] = ByteBuffer.zigZagDecode64(val[\"value\"]);\r\n            else\r\n                val = ByteBuffer.zigZagDecode64(val);\r\n            return val;\r\n        };\r\n\r\n    } // Long\r\n\r\n\r\n    // types/strings/cstring\r\n\r\n    /**\r\n     * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL\r\n     *  characters itself.\r\n     * @param {string} str String to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  contained in `str` + 1 if omitted.\r\n     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeCString = function(str, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        var i,\r\n            k = str.length;\r\n        if (!this.noAssert) {\r\n            if (typeof str !== 'string')\r\n                throw TypeError(\"Illegal str: Not a string\");\r\n            for (i=0; i<k; ++i) {\r\n                if (str.charCodeAt(i) === 0)\r\n                    throw RangeError(\"Illegal str: Contains NULL-characters\");\r\n            }\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        // UTF8 strings do not contain zero bytes in between except for the zero character, so:\r\n        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];\r\n        offset += k+1;\n        var capacity12 = this.buffer.byteLength;\n        if (offset > capacity12)\n            this.resize((capacity12 *= 2) > offset ? capacity12 : offset);\n        offset -= k+1;\n        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {\r\n            this.view[offset++] = b;\r\n        }.bind(this));\r\n        this.view[offset++] = 0;\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return this;\r\n        }\r\n        return k;\r\n    };\r\n\r\n    /**\r\n     * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters\r\n     *  itself.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  read if omitted.\r\n     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string\r\n     *  read and the actual number of bytes read.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readCString = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 1 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+1+\") <= \"+this.buffer.byteLength);\n        }\r\n        var start = offset,\r\n            temp;\r\n        // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:\r\n        var sd, b = -1;\r\n        utfx.decodeUTF8toUTF16(function() {\r\n            if (b === 0) return null;\r\n            if (offset >= this.limit)\r\n                throw RangeError(\"Illegal range: Truncated data, \"+offset+\" < \"+this.limit);\r\n            b = this.view[offset++];\r\n            return b === 0 ? null : b;\r\n        }.bind(this), sd = stringDestination(), true);\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return sd();\r\n        } else {\r\n            return {\r\n                \"string\": sd(),\r\n                \"length\": offset - start\r\n            };\r\n        }\r\n    };\r\n\r\n    // types/strings/istring\r\n\r\n    /**\r\n     * Writes a length as uint32 prefixed UTF8 encoded string.\r\n     * @param {string} str String to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written\r\n     * @expose\r\n     * @see ByteBuffer#writeVarint32\r\n     */\r\n    ByteBufferPrototype.writeIString = function(str, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof str !== 'string')\r\n                throw TypeError(\"Illegal str: Not a string\");\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        var start = offset,\r\n            k;\r\n        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];\r\n        offset += 4+k;\n        var capacity13 = this.buffer.byteLength;\n        if (offset > capacity13)\n            this.resize((capacity13 *= 2) > offset ? capacity13 : offset);\n        offset -= 4+k;\n        if (this.littleEndian) {\n            this.view[offset+3] = (k >>> 24) & 0xFF;\n            this.view[offset+2] = (k >>> 16) & 0xFF;\n            this.view[offset+1] = (k >>>  8) & 0xFF;\n            this.view[offset  ] =  k         & 0xFF;\n        } else {\n            this.view[offset  ] = (k >>> 24) & 0xFF;\n            this.view[offset+1] = (k >>> 16) & 0xFF;\n            this.view[offset+2] = (k >>>  8) & 0xFF;\n            this.view[offset+3] =  k         & 0xFF;\n        }\n        offset += 4;\r\n        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {\r\n            this.view[offset++] = b;\r\n        }.bind(this));\r\n        if (offset !== start + 4 + k)\r\n            throw RangeError(\"Illegal range: Truncated data, \"+offset+\" == \"+(offset+4+k));\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return this;\r\n        }\r\n        return offset - start;\r\n    };\r\n\r\n    /**\r\n     * Reads a length as uint32 prefixed UTF8 encoded string.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  read if omitted.\r\n     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string\r\n     *  read and the actual number of bytes read.\r\n     * @expose\r\n     * @see ByteBuffer#readVarint32\r\n     */\r\n    ByteBufferPrototype.readIString = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 4 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+4+\") <= \"+this.buffer.byteLength);\n        }\r\n        var start = offset;\r\n        var len = this.readUint32(offset);\r\n        var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);\r\n        offset += str['length'];\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return str['string'];\r\n        } else {\r\n            return {\r\n                'string': str['string'],\r\n                'length': offset - start\r\n            };\r\n        }\r\n    };\r\n\r\n    // types/strings/utf8string\r\n\r\n    /**\r\n     * Metrics representing number of UTF8 characters. Evaluates to `c`.\r\n     * @type {string}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ByteBuffer.METRICS_CHARS = 'c';\r\n\r\n    /**\r\n     * Metrics representing number of bytes. Evaluates to `b`.\r\n     * @type {string}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ByteBuffer.METRICS_BYTES = 'b';\r\n\r\n    /**\r\n     * Writes an UTF8 encoded string.\r\n     * @param {string} str String to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.\r\n     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeUTF8String = function(str, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        var k;\r\n        var start = offset;\r\n        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];\r\n        offset += k;\n        var capacity14 = this.buffer.byteLength;\n        if (offset > capacity14)\n            this.resize((capacity14 *= 2) > offset ? capacity14 : offset);\n        offset -= k;\n        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {\r\n            this.view[offset++] = b;\r\n        }.bind(this));\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return this;\r\n        }\r\n        return offset - start;\r\n    };\r\n\r\n    /**\r\n     * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.\r\n     * @function\r\n     * @param {string} str String to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.\r\n     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;\r\n\r\n    /**\r\n     * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's\r\n     *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.\r\n     * @param {string} str String to calculate\r\n     * @returns {number} Number of UTF8 characters\r\n     * @expose\r\n     */\r\n    ByteBuffer.calculateUTF8Chars = function(str) {\r\n        return utfx.calculateUTF16asUTF8(stringSource(str))[0];\r\n    };\r\n\r\n    /**\r\n     * Calculates the number of UTF8 bytes of a string.\r\n     * @param {string} str String to calculate\r\n     * @returns {number} Number of UTF8 bytes\r\n     * @expose\r\n     */\r\n    ByteBuffer.calculateUTF8Bytes = function(str) {\r\n        return utfx.calculateUTF16asUTF8(stringSource(str))[1];\r\n    };\r\n\r\n    /**\r\n     * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.\r\n     * @function\r\n     * @param {string} str String to calculate\r\n     * @returns {number} Number of UTF8 bytes\r\n     * @expose\r\n     */\r\n    ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;\r\n\r\n    /**\r\n     * Reads an UTF8 encoded string.\r\n     * @param {number} length Number of characters or bytes to read.\r\n     * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to\r\n     *  {@link ByteBuffer.METRICS_CHARS}.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  read if omitted.\r\n     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string\r\n     *  read and the actual number of bytes read.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readUTF8String = function(length, metrics, offset) {\r\n        if (typeof metrics === 'number') {\r\n            offset = metrics;\r\n            metrics = undefined;\r\n        }\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;\r\n        if (!this.noAssert) {\r\n            if (typeof length !== 'number' || length % 1 !== 0)\n                throw TypeError(\"Illegal length: \"+length+\" (not an integer)\");\n            length |= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        var i = 0,\r\n            start = offset,\r\n            sd;\r\n        if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser\r\n            sd = stringDestination();\r\n            utfx.decodeUTF8(function() {\r\n                return i < length && offset < this.limit ? this.view[offset++] : null;\r\n            }.bind(this), function(cp) {\r\n                ++i; utfx.UTF8toUTF16(cp, sd);\r\n            });\r\n            if (i !== length)\r\n                throw RangeError(\"Illegal range: Truncated data, \"+i+\" == \"+length);\r\n            if (relative) {\r\n                this.offset = offset;\r\n                return sd();\r\n            } else {\r\n                return {\r\n                    \"string\": sd(),\r\n                    \"length\": offset - start\r\n                };\r\n            }\r\n        } else if (metrics === ByteBuffer.METRICS_BYTES) {\r\n            if (!this.noAssert) {\r\n                if (typeof offset !== 'number' || offset % 1 !== 0)\n                    throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n                offset >>>= 0;\n                if (offset < 0 || offset + length > this.buffer.byteLength)\n                    throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+length+\") <= \"+this.buffer.byteLength);\n            }\r\n            var k = offset + length;\r\n            utfx.decodeUTF8toUTF16(function() {\r\n                return offset < k ? this.view[offset++] : null;\r\n            }.bind(this), sd = stringDestination(), this.noAssert);\r\n            if (offset !== k)\r\n                throw RangeError(\"Illegal range: Truncated data, \"+offset+\" == \"+k);\r\n            if (relative) {\r\n                this.offset = offset;\r\n                return sd();\r\n            } else {\r\n                return {\r\n                    'string': sd(),\r\n                    'length': offset - start\r\n                };\r\n            }\r\n        } else\r\n            throw TypeError(\"Unsupported metrics: \"+metrics);\r\n    };\r\n\r\n    /**\r\n     * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.\r\n     * @function\r\n     * @param {number} length Number of characters or bytes to read\r\n     * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to\r\n     *  {@link ByteBuffer.METRICS_CHARS}.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  read if omitted.\r\n     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string\r\n     *  read and the actual number of bytes read.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;\r\n\r\n    // types/strings/vstring\r\n\r\n    /**\r\n     * Writes a length as varint32 prefixed UTF8 encoded string.\r\n     * @param {string} str String to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written\r\n     * @expose\r\n     * @see ByteBuffer#writeVarint32\r\n     */\r\n    ByteBufferPrototype.writeVString = function(str, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof str !== 'string')\r\n                throw TypeError(\"Illegal str: Not a string\");\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        var start = offset,\r\n            k, l;\r\n        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];\r\n        l = ByteBuffer.calculateVarint32(k);\r\n        offset += l+k;\n        var capacity15 = this.buffer.byteLength;\n        if (offset > capacity15)\n            this.resize((capacity15 *= 2) > offset ? capacity15 : offset);\n        offset -= l+k;\n        offset += this.writeVarint32(k, offset);\r\n        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {\r\n            this.view[offset++] = b;\r\n        }.bind(this));\r\n        if (offset !== start+k+l)\r\n            throw RangeError(\"Illegal range: Truncated data, \"+offset+\" == \"+(offset+k+l));\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return this;\r\n        }\r\n        return offset - start;\r\n    };\r\n\r\n    /**\r\n     * Reads a length as varint32 prefixed UTF8 encoded string.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  read if omitted.\r\n     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string\r\n     *  read and the actual number of bytes read.\r\n     * @expose\r\n     * @see ByteBuffer#readVarint32\r\n     */\r\n    ByteBufferPrototype.readVString = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 1 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+1+\") <= \"+this.buffer.byteLength);\n        }\r\n        var start = offset;\r\n        var len = this.readVarint32(offset);\r\n        var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']);\r\n        offset += str['length'];\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return str['string'];\r\n        } else {\r\n            return {\r\n                'string': str['string'],\r\n                'length': offset - start\r\n            };\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended\r\n     *  data's length.\r\n     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets\r\n     *  will be modified according to the performed read operation.\r\n     * @param {(string|number)=} encoding Encoding if `data` is a string (\"base64\", \"hex\", \"binary\", defaults to \"utf8\")\r\n     * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`\r\n     * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`\r\n     */\r\n    ByteBufferPrototype.append = function(source, encoding, offset) {\r\n        if (typeof encoding === 'number' || typeof encoding !== 'string') {\r\n            offset = encoding;\r\n            encoding = undefined;\r\n        }\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        if (!(source instanceof ByteBuffer))\r\n            source = ByteBuffer.wrap(source, encoding);\r\n        var length = source.limit - source.offset;\r\n        if (length <= 0) return this; // Nothing to append\r\n        offset += length;\n        var capacity16 = this.buffer.byteLength;\n        if (offset > capacity16)\n            this.resize((capacity16 *= 2) > offset ? capacity16 : offset);\n        offset -= length;\n        this.view.set(source.view.subarray(source.offset, source.limit), offset);\r\n        source.offset += length;\r\n        if (relative) this.offset += length;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the\r\n        specified offset up to the length of this ByteBuffer's data.\r\n     * @param {!ByteBuffer} target Target ByteBuffer\r\n     * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  read if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     * @see ByteBuffer#append\r\n     */\r\n    ByteBufferPrototype.appendTo = function(target, offset) {\r\n        target.append(this, offset);\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to\r\n     *  disable them if your code already makes sure that everything is valid.\r\n     * @param {boolean} assert `true` to enable assertions, otherwise `false`\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.assert = function(assert) {\r\n        this.noAssert = !assert;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Gets the capacity of this ByteBuffer's backing buffer.\r\n     * @returns {number} Capacity of the backing buffer\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.capacity = function() {\r\n        return this.buffer.byteLength;\r\n    };\r\n    /**\r\n     * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the\r\n     *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.clear = function() {\r\n        this.offset = 0;\r\n        this.limit = this.buffer.byteLength;\r\n        this.markedOffset = -1;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},\r\n     *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.\r\n     * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`\r\n     * @returns {!ByteBuffer} Cloned instance\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.clone = function(copy) {\r\n        var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);\r\n        if (copy) {\r\n            bb.buffer = new ArrayBuffer(this.buffer.byteLength);\r\n            bb.view = new Uint8Array(bb.buffer);\r\n        } else {\r\n            bb.buffer = this.buffer;\r\n            bb.view = this.view;\r\n        }\r\n        bb.offset = this.offset;\r\n        bb.markedOffset = this.markedOffset;\r\n        bb.limit = this.limit;\r\n        return bb;\r\n    };\r\n\r\n    /**\r\n     * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes\r\n     *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and\r\n     *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.\r\n     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}\r\n     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.compact = function(begin, end) {\r\n        if (typeof begin === 'undefined') begin = this.offset;\r\n        if (typeof end === 'undefined') end = this.limit;\r\n        if (!this.noAssert) {\r\n            if (typeof begin !== 'number' || begin % 1 !== 0)\n                throw TypeError(\"Illegal begin: Not an integer\");\n            begin >>>= 0;\n            if (typeof end !== 'number' || end % 1 !== 0)\n                throw TypeError(\"Illegal end: Not an integer\");\n            end >>>= 0;\n            if (begin < 0 || begin > end || end > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+begin+\" <= \"+end+\" <= \"+this.buffer.byteLength);\n        }\r\n        if (begin === 0 && end === this.buffer.byteLength)\r\n            return this; // Already compacted\r\n        var len = end - begin;\r\n        if (len === 0) {\r\n            this.buffer = EMPTY_BUFFER;\r\n            this.view = null;\r\n            if (this.markedOffset >= 0) this.markedOffset -= begin;\r\n            this.offset = 0;\r\n            this.limit = 0;\r\n            return this;\r\n        }\r\n        var buffer = new ArrayBuffer(len);\r\n        var view = new Uint8Array(buffer);\r\n        view.set(this.view.subarray(begin, end));\r\n        this.buffer = buffer;\r\n        this.view = view;\r\n        if (this.markedOffset >= 0) this.markedOffset -= begin;\r\n        this.offset = 0;\r\n        this.limit = len;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and\r\n     *  {@link ByteBuffer#limit}.\r\n     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.\r\n     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.\r\n     * @returns {!ByteBuffer} Copy\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.copy = function(begin, end) {\r\n        if (typeof begin === 'undefined') begin = this.offset;\r\n        if (typeof end === 'undefined') end = this.limit;\r\n        if (!this.noAssert) {\r\n            if (typeof begin !== 'number' || begin % 1 !== 0)\n                throw TypeError(\"Illegal begin: Not an integer\");\n            begin >>>= 0;\n            if (typeof end !== 'number' || end % 1 !== 0)\n                throw TypeError(\"Illegal end: Not an integer\");\n            end >>>= 0;\n            if (begin < 0 || begin > end || end > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+begin+\" <= \"+end+\" <= \"+this.buffer.byteLength);\n        }\r\n        if (begin === end)\r\n            return new ByteBuffer(0, this.littleEndian, this.noAssert);\r\n        var capacity = end - begin,\r\n            bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);\r\n        bb.offset = 0;\r\n        bb.limit = capacity;\r\n        if (bb.markedOffset >= 0) bb.markedOffset -= begin;\r\n        this.copyTo(bb, 0, begin, end);\r\n        return bb;\r\n    };\r\n\r\n    /**\r\n     * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and\r\n     *  {@link ByteBuffer#limit}.\r\n     * @param {!ByteBuffer} target Target ByteBuffer\r\n     * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}\r\n     *  by the number of bytes copied if omitted.\r\n     * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the\r\n     *  number of bytes copied if omitted.\r\n     * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) {\r\n        var relative,\r\n            targetRelative;\r\n        if (!this.noAssert) {\r\n            if (!ByteBuffer.isByteBuffer(target))\r\n                throw TypeError(\"Illegal target: Not a ByteBuffer\");\r\n        }\r\n        targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;\r\n        sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;\r\n        sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;\r\n\r\n        if (targetOffset < 0 || targetOffset > target.buffer.byteLength)\r\n            throw RangeError(\"Illegal target range: 0 <= \"+targetOffset+\" <= \"+target.buffer.byteLength);\r\n        if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength)\r\n            throw RangeError(\"Illegal source range: 0 <= \"+sourceOffset+\" <= \"+this.buffer.byteLength);\r\n\r\n        var len = sourceLimit - sourceOffset;\r\n        if (len === 0)\r\n            return target; // Nothing to copy\r\n\r\n        target.ensureCapacity(targetOffset + len);\r\n\r\n        target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset);\r\n\r\n        if (relative) this.offset += len;\r\n        if (targetRelative) target.offset += len;\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the\r\n     *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,\r\n     *  the required capacity will be used instead.\r\n     * @param {number} capacity Required capacity\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.ensureCapacity = function(capacity) {\r\n        var current = this.buffer.byteLength;\r\n        if (current < capacity)\r\n            return this.resize((current *= 2) > capacity ? current : capacity);\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between\r\n     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.\r\n     * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.\r\n     * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted. defaults to {@link ByteBuffer#offset}.\r\n     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes\r\n     */\r\n    ByteBufferPrototype.fill = function(value, begin, end) {\r\n        var relative = typeof begin === 'undefined';\n        if (relative) begin = this.offset;\n        if (typeof value === 'string' && value.length > 0)\r\n            value = value.charCodeAt(0);\r\n        if (typeof begin === 'undefined') begin = this.offset;\r\n        if (typeof end === 'undefined') end = this.limit;\r\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value |= 0;\n            if (typeof begin !== 'number' || begin % 1 !== 0)\n                throw TypeError(\"Illegal begin: Not an integer\");\n            begin >>>= 0;\n            if (typeof end !== 'number' || end % 1 !== 0)\n                throw TypeError(\"Illegal end: Not an integer\");\n            end >>>= 0;\n            if (begin < 0 || begin > end || end > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+begin+\" <= \"+end+\" <= \"+this.buffer.byteLength);\n        }\r\n        if (begin >= end)\r\n            return this; // Nothing to fill\r\n        while (begin < end) this.view[begin++] = value;\r\n        if (relative) this.offset = begin;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and\r\n     *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.flip = function() {\r\n        this.limit = this.offset;\r\n        this.offset = 0;\r\n        return this;\r\n    };\r\n    /**\r\n     * Marks an offset on this ByteBuffer to be used later.\r\n     * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.\r\n     * @returns {!ByteBuffer} this\r\n     * @throws {TypeError} If `offset` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @see ByteBuffer#reset\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.mark = function(offset) {\r\n        offset = typeof offset === 'undefined' ? this.offset : offset;\r\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        this.markedOffset = offset;\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the byte order.\r\n     * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.order = function(littleEndian) {\r\n        if (!this.noAssert) {\r\n            if (typeof littleEndian !== 'boolean')\r\n                throw TypeError(\"Illegal littleEndian: Not a boolean\");\r\n        }\r\n        this.littleEndian = !!littleEndian;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Switches (to) little endian byte order.\r\n     * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.LE = function(littleEndian) {\r\n        this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Switches (to) big endian byte order.\r\n     * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.BE = function(bigEndian) {\r\n        this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;\r\n        return this;\r\n    };\r\n    /**\r\n     * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the\r\n     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer\r\n     *  will be resized and its contents moved accordingly.\r\n     * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be\r\n     *  modified according to the performed read operation.\r\n     * @param {(string|number)=} encoding Encoding if `data` is a string (\"base64\", \"hex\", \"binary\", defaults to \"utf8\")\r\n     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes\r\n     *  prepended if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`\r\n     * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`\r\n     */\r\n    ByteBufferPrototype.prepend = function(source, encoding, offset) {\r\n        if (typeof encoding === 'number' || typeof encoding !== 'string') {\r\n            offset = encoding;\r\n            encoding = undefined;\r\n        }\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        if (!(source instanceof ByteBuffer))\r\n            source = ByteBuffer.wrap(source, encoding);\r\n        var len = source.limit - source.offset;\r\n        if (len <= 0) return this; // Nothing to prepend\r\n        var diff = len - offset;\r\n        if (diff > 0) { // Not enough space before offset, so resize + move\r\n            var buffer = new ArrayBuffer(this.buffer.byteLength + diff);\r\n            var view = new Uint8Array(buffer);\r\n            view.set(this.view.subarray(offset, this.buffer.byteLength), len);\r\n            this.buffer = buffer;\r\n            this.view = view;\r\n            this.offset += diff;\r\n            if (this.markedOffset >= 0) this.markedOffset += diff;\r\n            this.limit += diff;\r\n            offset += diff;\r\n        } else {\r\n            var arrayView = new Uint8Array(this.buffer);\r\n        }\r\n        this.view.set(source.view.subarray(source.offset, source.limit), offset - len);\r\n\r\n        source.offset = source.limit;\r\n        if (relative)\r\n            this.offset -= len;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the\r\n     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer\r\n     *  will be resized and its contents moved accordingly.\r\n     * @param {!ByteBuffer} target Target ByteBuffer\r\n     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes\r\n     *  prepended if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     * @see ByteBuffer#prepend\r\n     */\r\n    ByteBufferPrototype.prependTo = function(target, offset) {\r\n        target.prepend(this, offset);\r\n        return this;\r\n    };\r\n    /**\r\n     * Prints debug information about this ByteBuffer's contents.\r\n     * @param {function(string)=} out Output function to call, defaults to console.log\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.printDebug = function(out) {\r\n        if (typeof out !== 'function') out = console.log.bind(console);\r\n        out(\r\n            this.toString()+\"\\n\"+\r\n            \"-------------------------------------------------------------------\\n\"+\r\n            this.toDebug(/* columns */ true)\r\n        );\r\n    };\r\n\r\n    /**\r\n     * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and\r\n     *  {@link ByteBuffer#limit}, so this returns `limit - offset`.\r\n     * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.remaining = function() {\r\n        return this.limit - this.offset;\r\n    };\r\n    /**\r\n     * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}\r\n     *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been\r\n     *  marked, sets `offset = 0`.\r\n     * @returns {!ByteBuffer} this\r\n     * @see ByteBuffer#mark\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.reset = function() {\r\n        if (this.markedOffset >= 0) {\r\n            this.offset = this.markedOffset;\r\n            this.markedOffset = -1;\r\n        } else {\r\n            this.offset = 0;\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that\r\n     *  large or larger.\r\n     * @param {number} capacity Capacity required\r\n     * @returns {!ByteBuffer} this\r\n     * @throws {TypeError} If `capacity` is not a number\r\n     * @throws {RangeError} If `capacity < 0`\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.resize = function(capacity) {\r\n        if (!this.noAssert) {\r\n            if (typeof capacity !== 'number' || capacity % 1 !== 0)\n                throw TypeError(\"Illegal capacity: \"+capacity+\" (not an integer)\");\n            capacity |= 0;\n            if (capacity < 0)\r\n                throw RangeError(\"Illegal capacity: 0 <= \"+capacity);\r\n        }\r\n        if (this.buffer.byteLength < capacity) {\r\n            var buffer = new ArrayBuffer(capacity);\r\n            var view = new Uint8Array(buffer);\r\n            view.set(this.view);\r\n            this.buffer = buffer;\r\n            this.view = view;\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Reverses this ByteBuffer's contents.\r\n     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}\r\n     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.reverse = function(begin, end) {\r\n        if (typeof begin === 'undefined') begin = this.offset;\r\n        if (typeof end === 'undefined') end = this.limit;\r\n        if (!this.noAssert) {\r\n            if (typeof begin !== 'number' || begin % 1 !== 0)\n                throw TypeError(\"Illegal begin: Not an integer\");\n            begin >>>= 0;\n            if (typeof end !== 'number' || end % 1 !== 0)\n                throw TypeError(\"Illegal end: Not an integer\");\n            end >>>= 0;\n            if (begin < 0 || begin > end || end > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+begin+\" <= \"+end+\" <= \"+this.buffer.byteLength);\n        }\r\n        if (begin === end)\r\n            return this; // Nothing to reverse\r\n        Array.prototype.reverse.call(this.view.subarray(begin, end));\r\n        return this;\r\n    };\r\n    /**\r\n     * Skips the next `length` bytes. This will just advance\r\n     * @param {number} length Number of bytes to skip. May also be negative to move the offset back.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.skip = function(length) {\r\n        if (!this.noAssert) {\r\n            if (typeof length !== 'number' || length % 1 !== 0)\n                throw TypeError(\"Illegal length: \"+length+\" (not an integer)\");\n            length |= 0;\n        }\r\n        var offset = this.offset + length;\r\n        if (!this.noAssert) {\r\n            if (offset < 0 || offset > this.buffer.byteLength)\r\n                throw RangeError(\"Illegal length: 0 <= \"+this.offset+\" + \"+length+\" <= \"+this.buffer.byteLength);\r\n        }\r\n        this.offset = offset;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.\r\n     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.\r\n     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.\r\n     * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.slice = function(begin, end) {\r\n        if (typeof begin === 'undefined') begin = this.offset;\r\n        if (typeof end === 'undefined') end = this.limit;\r\n        if (!this.noAssert) {\r\n            if (typeof begin !== 'number' || begin % 1 !== 0)\n                throw TypeError(\"Illegal begin: Not an integer\");\n            begin >>>= 0;\n            if (typeof end !== 'number' || end % 1 !== 0)\n                throw TypeError(\"Illegal end: Not an integer\");\n            end >>>= 0;\n            if (begin < 0 || begin > end || end > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+begin+\" <= \"+end+\" <= \"+this.buffer.byteLength);\n        }\r\n        var bb = this.clone();\r\n        bb.offset = begin;\r\n        bb.limit = end;\r\n        return bb;\r\n    };\r\n    /**\r\n     * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between\r\n     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.\r\n     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if\r\n     *  possible. Defaults to `false`\r\n     * @returns {!ArrayBuffer} Contents as an ArrayBuffer\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.toBuffer = function(forceCopy) {\r\n        var offset = this.offset,\r\n            limit = this.limit;\r\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: Not an integer\");\n            offset >>>= 0;\n            if (typeof limit !== 'number' || limit % 1 !== 0)\n                throw TypeError(\"Illegal limit: Not an integer\");\n            limit >>>= 0;\n            if (offset < 0 || offset > limit || limit > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+offset+\" <= \"+limit+\" <= \"+this.buffer.byteLength);\n        }\r\n        // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is\r\n        // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:\r\n        if (!forceCopy && offset === 0 && limit === this.buffer.byteLength)\r\n            return this.buffer;\r\n        if (offset === limit)\r\n            return EMPTY_BUFFER;\r\n        var buffer = new ArrayBuffer(limit - offset);\r\n        new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);\r\n        return buffer;\r\n    };\r\n\r\n    /**\r\n     * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between\r\n     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.\r\n     * @function\r\n     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.\r\n     *  Defaults to `false`\r\n     * @returns {!ArrayBuffer} Contents as an ArrayBuffer\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;\r\n\r\n    /**\r\n     * Converts the ByteBuffer's contents to a string.\r\n     * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows\r\n     *  direct conversion to \"utf8\", \"hex\", \"base64\" and \"binary\" encoding. \"debug\" returns a hex representation with\r\n     *  highlighted offsets.\r\n     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}\r\n     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}\r\n     * @returns {string} String representation\r\n     * @throws {Error} If `encoding` is invalid\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.toString = function(encoding, begin, end) {\r\n        if (typeof encoding === 'undefined')\r\n            return \"ByteBufferAB(offset=\"+this.offset+\",markedOffset=\"+this.markedOffset+\",limit=\"+this.limit+\",capacity=\"+this.capacity()+\")\";\r\n        if (typeof encoding === 'number')\r\n            encoding = \"utf8\",\r\n            begin = encoding,\r\n            end = begin;\r\n        switch (encoding) {\r\n            case \"utf8\":\r\n                return this.toUTF8(begin, end);\r\n            case \"base64\":\r\n                return this.toBase64(begin, end);\r\n            case \"hex\":\r\n                return this.toHex(begin, end);\r\n            case \"binary\":\r\n                return this.toBinary(begin, end);\r\n            case \"debug\":\r\n                return this.toDebug();\r\n            case \"columns\":\r\n                return this.toColumns();\r\n            default:\r\n                throw Error(\"Unsupported encoding: \"+encoding);\r\n        }\r\n    };\r\n\r\n    // lxiv-embeddable\r\n\r\n    /**\r\n     * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>\r\n     * Released under the Apache License, Version 2.0\r\n     * see: https://github.com/dcodeIO/lxiv for details\r\n     */\r\n    var lxiv = function() {\r\n        \"use strict\";\r\n\r\n        /**\r\n         * lxiv namespace.\r\n         * @type {!Object.<string,*>}\r\n         * @exports lxiv\r\n         */\r\n        var lxiv = {};\r\n\r\n        /**\r\n         * Character codes for output.\r\n         * @type {!Array.<number>}\r\n         * @inner\r\n         */\r\n        var aout = [\r\n            65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\r\n            81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102,\r\n            103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,\r\n            119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47\r\n        ];\r\n\r\n        /**\r\n         * Character codes for input.\r\n         * @type {!Array.<number>}\r\n         * @inner\r\n         */\r\n        var ain = [];\r\n        for (var i=0, k=aout.length; i<k; ++i)\r\n            ain[aout[i]] = i;\r\n\r\n        /**\r\n         * Encodes bytes to base64 char codes.\r\n         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if\r\n         *  there are no more bytes left.\r\n         * @param {!function(number)} dst Characters destination as a function successively called with each encoded char\r\n         *  code.\r\n         */\r\n        lxiv.encode = function(src, dst) {\r\n            var b, t;\r\n            while ((b = src()) !== null) {\r\n                dst(aout[(b>>2)&0x3f]);\r\n                t = (b&0x3)<<4;\r\n                if ((b = src()) !== null) {\r\n                    t |= (b>>4)&0xf;\r\n                    dst(aout[(t|((b>>4)&0xf))&0x3f]);\r\n                    t = (b&0xf)<<2;\r\n                    if ((b = src()) !== null)\r\n                        dst(aout[(t|((b>>6)&0x3))&0x3f]),\r\n                        dst(aout[b&0x3f]);\r\n                    else\r\n                        dst(aout[t&0x3f]),\r\n                        dst(61);\r\n                } else\r\n                    dst(aout[t&0x3f]),\r\n                    dst(61),\r\n                    dst(61);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Decodes base64 char codes to bytes.\r\n         * @param {!function():number|null} src Characters source as a function returning the next char code respectively\r\n         *  `null` if there are no more characters left.\r\n         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.\r\n         * @throws {Error} If a character code is invalid\r\n         */\r\n        lxiv.decode = function(src, dst) {\r\n            var c, t1, t2;\r\n            function fail(c) {\r\n                throw Error(\"Illegal character code: \"+c);\r\n            }\r\n            while ((c = src()) !== null) {\r\n                t1 = ain[c];\r\n                if (typeof t1 === 'undefined') fail(c);\r\n                if ((c = src()) !== null) {\r\n                    t2 = ain[c];\r\n                    if (typeof t2 === 'undefined') fail(c);\r\n                    dst((t1<<2)>>>0|(t2&0x30)>>4);\r\n                    if ((c = src()) !== null) {\r\n                        t1 = ain[c];\r\n                        if (typeof t1 === 'undefined')\r\n                            if (c === 61) break; else fail(c);\r\n                        dst(((t2&0xf)<<4)>>>0|(t1&0x3c)>>2);\r\n                        if ((c = src()) !== null) {\r\n                            t2 = ain[c];\r\n                            if (typeof t2 === 'undefined')\r\n                                if (c === 61) break; else fail(c);\r\n                            dst(((t1&0x3)<<6)>>>0|t2);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Tests if a string is valid base64.\r\n         * @param {string} str String to test\r\n         * @returns {boolean} `true` if valid, otherwise `false`\r\n         */\r\n        lxiv.test = function(str) {\r\n            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);\r\n        };\r\n\r\n        return lxiv;\r\n    }();\r\n\r\n    // encodings/base64\r\n\r\n    /**\r\n     * Encodes this ByteBuffer's contents to a base64 encoded string.\r\n     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.\r\n     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.\r\n     * @returns {string} Base64 encoded string\r\n     * @throws {RangeError} If `begin` or `end` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.toBase64 = function(begin, end) {\r\n        if (typeof begin === 'undefined')\r\n            begin = this.offset;\r\n        if (typeof end === 'undefined')\r\n            end = this.limit;\r\n        begin = begin | 0; end = end | 0;\r\n        if (begin < 0 || end > this.capacity || begin > end)\r\n            throw RangeError(\"begin, end\");\r\n        var sd; lxiv.encode(function() {\r\n            return begin < end ? this.view[begin++] : null;\r\n        }.bind(this), sd = stringDestination());\r\n        return sd();\r\n    };\r\n\r\n    /**\r\n     * Decodes a base64 encoded string to a ByteBuffer.\r\n     * @param {string} str String to decode\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @returns {!ByteBuffer} ByteBuffer\r\n     * @expose\r\n     */\r\n    ByteBuffer.fromBase64 = function(str, littleEndian) {\r\n        if (typeof str !== 'string')\r\n            throw TypeError(\"str\");\r\n        var bb = new ByteBuffer(str.length/4*3, littleEndian),\r\n            i = 0;\r\n        lxiv.decode(stringSource(str), function(b) {\r\n            bb.view[i++] = b;\r\n        });\r\n        bb.limit = i;\r\n        return bb;\r\n    };\r\n\r\n    /**\r\n     * Encodes a binary string to base64 like `window.btoa` does.\r\n     * @param {string} str Binary string\r\n     * @returns {string} Base64 encoded string\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa\r\n     * @expose\r\n     */\r\n    ByteBuffer.btoa = function(str) {\r\n        return ByteBuffer.fromBinary(str).toBase64();\r\n    };\r\n\r\n    /**\r\n     * Decodes a base64 encoded string to binary like `window.atob` does.\r\n     * @param {string} b64 Base64 encoded string\r\n     * @returns {string} Binary string\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob\r\n     * @expose\r\n     */\r\n    ByteBuffer.atob = function(b64) {\r\n        return ByteBuffer.fromBase64(b64).toBinary();\r\n    };\r\n\r\n    // encodings/binary\r\n\r\n    /**\r\n     * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.\r\n     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.\r\n     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.\r\n     * @returns {string} Binary encoded string\r\n     * @throws {RangeError} If `offset > limit`\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.toBinary = function(begin, end) {\r\n        if (typeof begin === 'undefined')\r\n            begin = this.offset;\r\n        if (typeof end === 'undefined')\r\n            end = this.limit;\r\n        begin |= 0; end |= 0;\r\n        if (begin < 0 || end > this.capacity() || begin > end)\r\n            throw RangeError(\"begin, end\");\r\n        if (begin === end)\r\n            return \"\";\r\n        var chars = [],\r\n            parts = [];\r\n        while (begin < end) {\r\n            chars.push(this.view[begin++]);\r\n            if (chars.length >= 1024)\r\n                parts.push(String.fromCharCode.apply(String, chars)),\r\n                chars = [];\r\n        }\r\n        return parts.join('') + String.fromCharCode.apply(String, chars);\r\n    };\r\n\r\n    /**\r\n     * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.\r\n     * @param {string} str String to decode\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @returns {!ByteBuffer} ByteBuffer\r\n     * @expose\r\n     */\r\n    ByteBuffer.fromBinary = function(str, littleEndian) {\r\n        if (typeof str !== 'string')\r\n            throw TypeError(\"str\");\r\n        var i = 0,\r\n            k = str.length,\r\n            charCode,\r\n            bb = new ByteBuffer(k, littleEndian);\r\n        while (i<k) {\r\n            charCode = str.charCodeAt(i);\r\n            if (charCode > 0xff)\r\n                throw RangeError(\"illegal char code: \"+charCode);\r\n            bb.view[i++] = charCode;\r\n        }\r\n        bb.limit = k;\r\n        return bb;\r\n    };\r\n\r\n    // encodings/debug\r\n\r\n    /**\r\n     * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:\r\n     * * `<` : offset,\r\n     * * `'` : markedOffset,\r\n     * * `>` : limit,\r\n     * * `|` : offset and limit,\r\n     * * `[` : offset and markedOffset,\r\n     * * `]` : markedOffset and limit,\r\n     * * `!` : offset, markedOffset and limit\r\n     * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`\r\n     * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`\r\n     * @expose\r\n     * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`\r\n     * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`\r\n     * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`\r\n     * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`\r\n     */\r\n    ByteBufferPrototype.toDebug = function(columns) {\r\n        var i = -1,\r\n            k = this.buffer.byteLength,\r\n            b,\r\n            hex = \"\",\r\n            asc = \"\",\r\n            out = \"\";\r\n        while (i<k) {\r\n            if (i !== -1) {\r\n                b = this.view[i];\r\n                if (b < 0x10) hex += \"0\"+b.toString(16).toUpperCase();\r\n                else hex += b.toString(16).toUpperCase();\r\n                if (columns)\r\n                    asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';\r\n            }\r\n            ++i;\r\n            if (columns) {\r\n                if (i > 0 && i % 16 === 0 && i !== k) {\r\n                    while (hex.length < 3*16+3) hex += \" \";\r\n                    out += hex+asc+\"\\n\";\r\n                    hex = asc = \"\";\r\n                }\r\n            }\r\n            if (i === this.offset && i === this.limit)\r\n                hex += i === this.markedOffset ? \"!\" : \"|\";\r\n            else if (i === this.offset)\r\n                hex += i === this.markedOffset ? \"[\" : \"<\";\r\n            else if (i === this.limit)\r\n                hex += i === this.markedOffset ? \"]\" : \">\";\r\n            else\r\n                hex += i === this.markedOffset ? \"'\" : (columns || (i !== 0 && i !== k) ? \" \" : \"\");\r\n        }\r\n        if (columns && hex !== \" \") {\r\n            while (hex.length < 3*16+3)\r\n                hex += \" \";\r\n            out += hex + asc + \"\\n\";\r\n        }\r\n        return columns ? out : hex;\r\n    };\r\n\r\n    /**\r\n     * Decodes a hex encoded string with marked offsets to a ByteBuffer.\r\n     * @param {string} str Debug string to decode (not be generated with `columns = true`)\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_NOASSERT}.\r\n     * @returns {!ByteBuffer} ByteBuffer\r\n     * @expose\r\n     * @see ByteBuffer#toDebug\r\n     */\r\n    ByteBuffer.fromDebug = function(str, littleEndian, noAssert) {\r\n        var k = str.length,\r\n            bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert);\r\n        var i = 0, j = 0, ch, b,\r\n            rs = false, // Require symbol next\r\n            ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?\r\n            fail = false;\r\n        while (i<k) {\r\n            switch (ch = str.charAt(i++)) {\r\n                case '!':\r\n                    if (!noAssert) {\r\n                        if (ho || hm || hl) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                        ho = hm = hl = true;\r\n                    }\r\n                    bb.offset = bb.markedOffset = bb.limit = j;\r\n                    rs = false;\r\n                    break;\r\n                case '|':\r\n                    if (!noAssert) {\r\n                        if (ho || hl) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                        ho = hl = true;\r\n                    }\r\n                    bb.offset = bb.limit = j;\r\n                    rs = false;\r\n                    break;\r\n                case '[':\r\n                    if (!noAssert) {\r\n                        if (ho || hm) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                        ho = hm = true;\r\n                    }\r\n                    bb.offset = bb.markedOffset = j;\r\n                    rs = false;\r\n                    break;\r\n                case '<':\r\n                    if (!noAssert) {\r\n                        if (ho) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                        ho = true;\r\n                    }\r\n                    bb.offset = j;\r\n                    rs = false;\r\n                    break;\r\n                case ']':\r\n                    if (!noAssert) {\r\n                        if (hl || hm) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                        hl = hm = true;\r\n                    }\r\n                    bb.limit = bb.markedOffset = j;\r\n                    rs = false;\r\n                    break;\r\n                case '>':\r\n                    if (!noAssert) {\r\n                        if (hl) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                        hl = true;\r\n                    }\r\n                    bb.limit = j;\r\n                    rs = false;\r\n                    break;\r\n                case \"'\":\r\n                    if (!noAssert) {\r\n                        if (hm) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                        hm = true;\r\n                    }\r\n                    bb.markedOffset = j;\r\n                    rs = false;\r\n                    break;\r\n                case ' ':\r\n                    rs = false;\r\n                    break;\r\n                default:\r\n                    if (!noAssert) {\r\n                        if (rs) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    b = parseInt(ch+str.charAt(i++), 16);\r\n                    if (!noAssert) {\r\n                        if (isNaN(b) || b < 0 || b > 255)\r\n                            throw TypeError(\"Illegal str: Not a debug encoded string\");\r\n                    }\r\n                    bb.view[j++] = b;\r\n                    rs = true;\r\n            }\r\n            if (fail)\r\n                throw TypeError(\"Illegal str: Invalid symbol at \"+i);\r\n        }\r\n        if (!noAssert) {\r\n            if (!ho || !hl)\r\n                throw TypeError(\"Illegal str: Missing offset or limit\");\r\n            if (j<bb.buffer.byteLength)\r\n                throw TypeError(\"Illegal str: Not a debug encoded string (is it hex?) \"+j+\" < \"+k);\r\n        }\r\n        return bb;\r\n    };\r\n\r\n    // encodings/hex\r\n\r\n    /**\r\n     * Encodes this ByteBuffer's contents to a hex encoded string.\r\n     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.\r\n     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.\r\n     * @returns {string} Hex encoded string\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.toHex = function(begin, end) {\r\n        begin = typeof begin === 'undefined' ? this.offset : begin;\r\n        end = typeof end === 'undefined' ? this.limit : end;\r\n        if (!this.noAssert) {\r\n            if (typeof begin !== 'number' || begin % 1 !== 0)\n                throw TypeError(\"Illegal begin: Not an integer\");\n            begin >>>= 0;\n            if (typeof end !== 'number' || end % 1 !== 0)\n                throw TypeError(\"Illegal end: Not an integer\");\n            end >>>= 0;\n            if (begin < 0 || begin > end || end > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+begin+\" <= \"+end+\" <= \"+this.buffer.byteLength);\n        }\r\n        var out = new Array(end - begin),\r\n            b;\r\n        while (begin < end) {\r\n            b = this.view[begin++];\r\n            if (b < 0x10)\r\n                out.push(\"0\", b.toString(16));\r\n            else out.push(b.toString(16));\r\n        }\r\n        return out.join('');\r\n    };\r\n\r\n    /**\r\n     * Decodes a hex encoded string to a ByteBuffer.\r\n     * @param {string} str String to decode\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_NOASSERT}.\r\n     * @returns {!ByteBuffer} ByteBuffer\r\n     * @expose\r\n     */\r\n    ByteBuffer.fromHex = function(str, littleEndian, noAssert) {\r\n        if (!noAssert) {\r\n            if (typeof str !== 'string')\r\n                throw TypeError(\"Illegal str: Not a string\");\r\n            if (str.length % 2 !== 0)\r\n                throw TypeError(\"Illegal str: Length not a multiple of 2\");\r\n        }\r\n        var k = str.length,\r\n            bb = new ByteBuffer((k / 2) | 0, littleEndian),\r\n            b;\r\n        for (var i=0, j=0; i<k; i+=2) {\r\n            b = parseInt(str.substring(i, i+2), 16);\r\n            if (!noAssert)\r\n                if (!isFinite(b) || b < 0 || b > 255)\r\n                    throw TypeError(\"Illegal str: Contains non-hex characters\");\r\n            bb.view[j++] = b;\r\n        }\r\n        bb.limit = j;\r\n        return bb;\r\n    };\r\n\r\n    // utfx-embeddable\r\n\r\n    /**\r\n     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>\r\n     * Released under the Apache License, Version 2.0\r\n     * see: https://github.com/dcodeIO/utfx for details\r\n     */\r\n    var utfx = function() {\r\n        \"use strict\";\r\n\r\n        /**\r\n         * utfx namespace.\r\n         * @inner\r\n         * @type {!Object.<string,*>}\r\n         */\r\n        var utfx = {};\r\n\r\n        /**\r\n         * Maximum valid code point.\r\n         * @type {number}\r\n         * @const\r\n         */\r\n        utfx.MAX_CODEPOINT = 0x10FFFF;\r\n\r\n        /**\r\n         * Encodes UTF8 code points to UTF8 bytes.\r\n         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point\r\n         *  respectively `null` if there are no more code points left or a single numeric code point.\r\n         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte\r\n         */\r\n        utfx.encodeUTF8 = function(src, dst) {\r\n            var cp = null;\r\n            if (typeof src === 'number')\r\n                cp = src,\r\n                src = function() { return null; };\r\n            while (cp !== null || (cp = src()) !== null) {\r\n                if (cp < 0x80)\r\n                    dst(cp&0x7F);\r\n                else if (cp < 0x800)\r\n                    dst(((cp>>6)&0x1F)|0xC0),\r\n                    dst((cp&0x3F)|0x80);\r\n                else if (cp < 0x10000)\r\n                    dst(((cp>>12)&0x0F)|0xE0),\r\n                    dst(((cp>>6)&0x3F)|0x80),\r\n                    dst((cp&0x3F)|0x80);\r\n                else\r\n                    dst(((cp>>18)&0x07)|0xF0),\r\n                    dst(((cp>>12)&0x3F)|0x80),\r\n                    dst(((cp>>6)&0x3F)|0x80),\r\n                    dst((cp&0x3F)|0x80);\r\n                cp = null;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Decodes UTF8 bytes to UTF8 code points.\r\n         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there\r\n         *  are no more bytes left.\r\n         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.\r\n         * @throws {RangeError} If a starting byte is invalid in UTF8\r\n         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the\r\n         *  remaining bytes.\r\n         */\r\n        utfx.decodeUTF8 = function(src, dst) {\r\n            var a, b, c, d, fail = function(b) {\r\n                b = b.slice(0, b.indexOf(null));\r\n                var err = Error(b.toString());\r\n                err.name = \"TruncatedError\";\r\n                err['bytes'] = b;\r\n                throw err;\r\n            };\r\n            while ((a = src()) !== null) {\r\n                if ((a&0x80) === 0)\r\n                    dst(a);\r\n                else if ((a&0xE0) === 0xC0)\r\n                    ((b = src()) === null) && fail([a, b]),\r\n                    dst(((a&0x1F)<<6) | (b&0x3F));\r\n                else if ((a&0xF0) === 0xE0)\r\n                    ((b=src()) === null || (c=src()) === null) && fail([a, b, c]),\r\n                    dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));\r\n                else if ((a&0xF8) === 0xF0)\r\n                    ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]),\r\n                    dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));\r\n                else throw RangeError(\"Illegal starting byte: \"+a);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Converts UTF16 characters to UTF8 code points.\r\n         * @param {!function():number|null} src Characters source as a function returning the next char code respectively\r\n         *  `null` if there are no more characters left.\r\n         * @param {!function(number)} dst Code points destination as a function successively called with each converted code\r\n         *  point.\r\n         */\r\n        utfx.UTF16toUTF8 = function(src, dst) {\r\n            var c1, c2 = null;\r\n            while (true) {\r\n                if ((c1 = c2 !== null ? c2 : src()) === null)\r\n                    break;\r\n                if (c1 >= 0xD800 && c1 <= 0xDFFF) {\r\n                    if ((c2 = src()) !== null) {\r\n                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {\r\n                            dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);\r\n                            c2 = null; continue;\r\n                        }\r\n                    }\r\n                }\r\n                dst(c1);\r\n            }\r\n            if (c2 !== null) dst(c2);\r\n        };\r\n\r\n        /**\r\n         * Converts UTF8 code points to UTF16 characters.\r\n         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point\r\n         *  respectively `null` if there are no more code points left or a single numeric code point.\r\n         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.\r\n         * @throws {RangeError} If a code point is out of range\r\n         */\r\n        utfx.UTF8toUTF16 = function(src, dst) {\r\n            var cp = null;\r\n            if (typeof src === 'number')\r\n                cp = src, src = function() { return null; };\r\n            while (cp !== null || (cp = src()) !== null) {\r\n                if (cp <= 0xFFFF)\r\n                    dst(cp);\r\n                else\r\n                    cp -= 0x10000,\r\n                    dst((cp>>10)+0xD800),\r\n                    dst((cp%0x400)+0xDC00);\r\n                cp = null;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Converts and encodes UTF16 characters to UTF8 bytes.\r\n         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`\r\n         *  if there are no more characters left.\r\n         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.\r\n         */\r\n        utfx.encodeUTF16toUTF8 = function(src, dst) {\r\n            utfx.UTF16toUTF8(src, function(cp) {\r\n                utfx.encodeUTF8(cp, dst);\r\n            });\r\n        };\r\n\r\n        /**\r\n         * Decodes and converts UTF8 bytes to UTF16 characters.\r\n         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there\r\n         *  are no more bytes left.\r\n         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.\r\n         * @throws {RangeError} If a starting byte is invalid in UTF8\r\n         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.\r\n         */\r\n        utfx.decodeUTF8toUTF16 = function(src, dst) {\r\n            utfx.decodeUTF8(src, function(cp) {\r\n                utfx.UTF8toUTF16(cp, dst);\r\n            });\r\n        };\r\n\r\n        /**\r\n         * Calculates the byte length of an UTF8 code point.\r\n         * @param {number} cp UTF8 code point\r\n         * @returns {number} Byte length\r\n         */\r\n        utfx.calculateCodePoint = function(cp) {\r\n            return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;\r\n        };\r\n\r\n        /**\r\n         * Calculates the number of UTF8 bytes required to store UTF8 code points.\r\n         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively\r\n         *  `null` if there are no more code points left.\r\n         * @returns {number} The number of UTF8 bytes required\r\n         */\r\n        utfx.calculateUTF8 = function(src) {\r\n            var cp, l=0;\r\n            while ((cp = src()) !== null)\r\n                l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;\r\n            return l;\r\n        };\r\n\r\n        /**\r\n         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.\r\n         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively\r\n         *  `null` if there are no more characters left.\r\n         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.\r\n         */\r\n        utfx.calculateUTF16asUTF8 = function(src) {\r\n            var n=0, l=0;\r\n            utfx.UTF16toUTF8(src, function(cp) {\r\n                ++n; l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;\r\n            });\r\n            return [n,l];\r\n        };\r\n\r\n        return utfx;\r\n    }();\r\n\r\n    // encodings/utf8\r\n\r\n    /**\r\n     * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded\r\n     *  string.\r\n     * @returns {string} Hex encoded string\r\n     * @throws {RangeError} If `offset > limit`\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.toUTF8 = function(begin, end) {\r\n        if (typeof begin === 'undefined') begin = this.offset;\r\n        if (typeof end === 'undefined') end = this.limit;\r\n        if (!this.noAssert) {\r\n            if (typeof begin !== 'number' || begin % 1 !== 0)\n                throw TypeError(\"Illegal begin: Not an integer\");\n            begin >>>= 0;\n            if (typeof end !== 'number' || end % 1 !== 0)\n                throw TypeError(\"Illegal end: Not an integer\");\n            end >>>= 0;\n            if (begin < 0 || begin > end || end > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+begin+\" <= \"+end+\" <= \"+this.buffer.byteLength);\n        }\r\n        var sd; try {\r\n            utfx.decodeUTF8toUTF16(function() {\r\n                return begin < end ? this.view[begin++] : null;\r\n            }.bind(this), sd = stringDestination());\r\n        } catch (e) {\r\n            if (begin !== end)\r\n                throw RangeError(\"Illegal range: Truncated data, \"+begin+\" != \"+end);\r\n        }\r\n        return sd();\r\n    };\r\n\r\n    /**\r\n     * Decodes an UTF8 encoded string to a ByteBuffer.\r\n     * @param {string} str String to decode\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_NOASSERT}.\r\n     * @returns {!ByteBuffer} ByteBuffer\r\n     * @expose\r\n     */\r\n    ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) {\r\n        if (!noAssert)\r\n            if (typeof str !== 'string')\r\n                throw TypeError(\"Illegal str: Not a string\");\r\n        var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert),\r\n            i = 0;\r\n        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {\r\n            bb.view[i++] = b;\r\n        });\r\n        bb.limit = i;\r\n        return bb;\r\n    };\r\n\r\n    return ByteBuffer;\r\n});\r\n","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar buildURL = require('./../helpers/buildURL');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\nvar btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || require('./../helpers/btoa');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n    var loadEvent = 'onreadystatechange';\n    var xDomain = false;\n\n    // For IE 8/9 CORS support\n    // Only supports POST and GET calls and doesn't returns the response headers.\n    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.\n    if (process.env.NODE_ENV !== 'test' &&\n        typeof window !== 'undefined' &&\n        window.XDomainRequest && !('withCredentials' in request) &&\n        !isURLSameOrigin(config.url)) {\n      request = new window.XDomainRequest();\n      loadEvent = 'onload';\n      xDomain = true;\n      request.onprogress = function handleProgress() {};\n      request.ontimeout = function handleTimeout() {};\n    }\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request[loadEvent] = function handleLoad() {\n      if (!request || (request.readyState !== 4 && !xDomain)) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)\n        status: request.status === 1223 ? 204 : request.status,\n        statusText: request.status === 1223 ? 'No Content' : request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = require('./../helpers/cookies');\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?\n          cookies.read(config.xsrfCookieName) :\n          undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (config.withCredentials) {\n      request.withCredentials = true;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n","/**\n * @module Numeric\n */\n// copyright defined in eosjs/LICENSE.txt\n\n// tslint:disable-next-line:no-var-requires\nconst ripemd160 = require(\"./ripemd\").RIPEMD160.hash as (a: Uint8Array) => ArrayBuffer;\n\nconst base58Chars = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nconst base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nfunction create_base58_map() {\n    const base58M = Array(256).fill(-1) as number[];\n    for (let i = 0; i < base58Chars.length; ++i) {\n        base58M[base58Chars.charCodeAt(i)] = i;\n    }\n    return base58M;\n}\n\nconst base58Map = create_base58_map();\n\nfunction create_base64_map() {\n    const base64M = Array(256).fill(-1) as number[];\n    for (let i = 0; i < base64Chars.length; ++i) {\n        base64M[base64Chars.charCodeAt(i)] = i;\n    }\n    base64M[\"=\".charCodeAt(0)] = 0;\n    return base64M;\n}\n\nconst base64Map = create_base64_map();\n\n/** Is `bignum` a negative number? */\nexport function isNegative(bignum: Uint8Array) {\n    return (bignum[bignum.length - 1] & 0x80) !== 0;\n}\n\n/** Negate `bignum` */\nexport function negate(bignum: Uint8Array) {\n    let carry = 1;\n    for (let i = 0; i < bignum.length; ++i) {\n        const x = (~bignum[i] & 0xff) + carry;\n        bignum[i] = x;\n        carry = x >> 8;\n    }\n}\n\n/**\n * Convert an unsigned decimal number in `s` to a bignum\n * @param size bignum size (bytes)\n */\nexport function decimalToBinary(size: number, s: string) {\n    const result = new Uint8Array(size);\n    for (let i = 0; i < s.length; ++i) {\n        const srcDigit = s.charCodeAt(i);\n        if (srcDigit < \"0\".charCodeAt(0) || srcDigit > \"9\".charCodeAt(0)) {\n            throw new Error(\"invalid number\");\n        }\n        let carry = srcDigit - \"0\".charCodeAt(0);\n        for (let j = 0; j < size; ++j) {\n            const x = result[j] * 10 + carry;\n            result[j] = x;\n            carry = x >> 8;\n        }\n        if (carry) {\n            throw new Error(\"number is out of range\");\n        }\n    }\n    return result;\n}\n\n/**\n * Convert a signed decimal number in `s` to a bignum\n * @param size bignum size (bytes)\n */\nexport function signedDecimalToBinary(size: number, s: string) {\n    const negative = s[0] === \"-\";\n    if (negative) {\n        s = s.substr(1);\n    }\n    const result = decimalToBinary(size, s);\n    if (negative) {\n        negate(result);\n        if (!isNegative(result)) {\n            throw new Error(\"number is out of range\");\n        }\n    } else if (isNegative(result)) {\n        throw new Error(\"number is out of range\");\n    }\n    return result;\n}\n\n/**\n * Convert `bignum` to an unsigned decimal number\n * @param minDigits 0-pad result to this many digits\n */\nexport function binaryToDecimal(bignum: Uint8Array, minDigits = 1) {\n    const result = Array(minDigits).fill(\"0\".charCodeAt(0)) as number[];\n    for (let i = bignum.length - 1; i >= 0; --i) {\n        let carry = bignum[i];\n        for (let j = 0; j < result.length; ++j) {\n            const x = ((result[j] - \"0\".charCodeAt(0)) << 8) + carry;\n            result[j] = \"0\".charCodeAt(0) + x % 10;\n            carry = (x / 10) | 0;\n        }\n        while (carry) {\n            result.push(\"0\".charCodeAt(0) + carry % 10);\n            carry = (carry / 10) | 0;\n        }\n    }\n    result.reverse();\n    return String.fromCharCode(...result);\n}\n\n/**\n * Convert `bignum` to a signed decimal number\n * @param minDigits 0-pad result to this many digits\n */\nexport function signedBinaryToDecimal(bignum: Uint8Array, minDigits = 1) {\n    if (isNegative(bignum)) {\n        const x = bignum.slice();\n        negate(x);\n        return \"-\" + binaryToDecimal(x, minDigits);\n    }\n    return binaryToDecimal(bignum, minDigits);\n}\n\n/**\n * Convert an unsigned base-58 number in `s` to a bignum\n * @param size bignum size (bytes)\n */\nexport function base58ToBinary(size: number, s: string) {\n    const result = new Uint8Array(size);\n    for (let i = 0; i < s.length; ++i) {\n        let carry = base58Map[s.charCodeAt(i)];\n        if (carry < 0) {\n            throw new Error(\"invalid base-58 value\");\n        }\n        for (let j = 0; j < size; ++j) {\n            const x = result[j] * 58 + carry;\n            result[j] = x;\n            carry = x >> 8;\n        }\n        if (carry) {\n            throw new Error(\"base-58 value is out of range\");\n        }\n    }\n    result.reverse();\n    return result;\n}\n\n/**\n * Convert `bignum` to a base-58 number\n * @param minDigits 0-pad result to this many digits\n */\nexport function binaryToBase58(bignum: Uint8Array, minDigits = 1) {\n    const result = [] as number[];\n    for (const byte of bignum) {\n        let carry = byte;\n        for (let j = 0; j < result.length; ++j) {\n            const x = (base58Map[result[j]] << 8) + carry;\n            result[j] = base58Chars.charCodeAt(x % 58);\n            carry = (x / 58) | 0;\n        }\n        while (carry) {\n            result.push(base58Chars.charCodeAt(carry % 58));\n            carry = (carry / 58) | 0;\n        }\n    }\n    for (const byte of bignum) {\n        if (byte) {\n            break;\n        } else {\n            result.push(\"1\".charCodeAt(0));\n        }\n    }\n    result.reverse();\n    return String.fromCharCode(...result);\n}\n\n/** Convert an unsigned base-64 number in `s` to a bignum */\nexport function base64ToBinary(s: string) {\n    let len = s.length;\n    if ((len & 3) === 1 && s[len - 1] === \"=\") {\n        len -= 1;\n    } // fc appends an extra '='\n    if ((len & 3) !== 0) {\n        throw new Error(\"base-64 value is not padded correctly\");\n    }\n    const groups = len >> 2;\n    let bytes = groups * 3;\n    if (len > 0 && s[len - 1] === \"=\") {\n        if (s[len - 2] === \"=\") {\n            bytes -= 2;\n        } else {\n            bytes -= 1;\n        }\n    }\n    const result = new Uint8Array(bytes);\n\n    for (let group = 0; group < groups; ++group) {\n        const digit0 = base64Map[s.charCodeAt(group * 4 + 0)];\n        const digit1 = base64Map[s.charCodeAt(group * 4 + 1)];\n        const digit2 = base64Map[s.charCodeAt(group * 4 + 2)];\n        const digit3 = base64Map[s.charCodeAt(group * 4 + 3)];\n        result[group * 3 + 0] = (digit0 << 2) | (digit1 >> 4);\n        if (group * 3 + 1 < bytes) {\n            result[group * 3 + 1] = ((digit1 & 15) << 4) | (digit2 >> 2);\n        }\n        if (group * 3 + 2 < bytes) {\n            result[group * 3 + 2] = ((digit2 & 3) << 6) | digit3;\n        }\n    }\n    return result;\n}\n\n/** Key types this library supports */\nexport const enum KeyType {\n    k1 = 0,\n    r1 = 1,\n}\n\n/** Public key data size, excluding type field */\nexport const publicKeyDataSize = 33;\n\n/** Private key data size, excluding type field */\nexport const privateKeyDataSize = 32;\n\n/** Signature data size, excluding type field */\nexport const signatureDataSize = 65;\n\n/** Public key, private key, or signature in binary form */\nexport interface Key {\n    type: KeyType;\n    data: Uint8Array;\n}\n\nfunction digestSuffixRipemd160(data: Uint8Array, suffix: string) {\n    const d = new Uint8Array(data.length + suffix.length);\n    for (let i = 0; i < data.length; ++i) {\n        d[i] = data[i];\n    }\n    for (let i = 0; i < suffix.length; ++i) {\n        d[data.length + i] = suffix.charCodeAt(i);\n    }\n    return ripemd160(d);\n}\n\nfunction stringToKey(s: string, type: KeyType, size: number, suffix: string): Key {\n    const whole = base58ToBinary(size + 4, s);\n    const result = { type, data: new Uint8Array(whole.buffer, 0, size) };\n    const digest = new Uint8Array(digestSuffixRipemd160(result.data, suffix));\n    if (digest[0] !== whole[size + 0] || digest[1] !== whole[size + 1]\n        || digest[2] !== whole[size + 2] || digest[3] !== whole[size + 3]) {\n        throw new Error(\"checksum doesn't match\");\n    }\n    return result;\n}\n\nfunction keyToString(key: Key, suffix: string, prefix: string) {\n    const digest = new Uint8Array(digestSuffixRipemd160(key.data, suffix));\n    const whole = new Uint8Array(key.data.length + 4);\n    for (let i = 0; i < key.data.length; ++i) {\n        whole[i] = key.data[i];\n    }\n    for (let i = 0; i < 4; ++i) {\n        whole[i + key.data.length] = digest[i];\n    }\n    return prefix + binaryToBase58(whole);\n}\n\n/** Convert key in `s` to binary form */\nexport function stringToPublicKey(s: string): Key {\n    if (typeof s !== \"string\") {\n        throw new Error(\"expected string containing public key\");\n    }\n    if (s.substr(0, 3) === \"EOS\") {\n        const whole = base58ToBinary(publicKeyDataSize + 4, s.substr(3));\n        const key = { type: KeyType.k1, data: new Uint8Array(publicKeyDataSize) };\n        for (let i = 0; i < publicKeyDataSize; ++i) {\n            key.data[i] = whole[i];\n        }\n        const digest = new Uint8Array(ripemd160(key.data));\n        if (digest[0] !== whole[publicKeyDataSize] || digest[1] !== whole[34]\n            || digest[2] !== whole[35] || digest[3] !== whole[36]) {\n            throw new Error(\"checksum doesn't match\");\n        }\n        return key;\n    } else if (s.substr(0, 7) === \"PUB_K1_\") {\n        return stringToKey(s.substr(7), KeyType.k1, publicKeyDataSize, \"K1\");\n    } else if (s.substr(0, 7) === \"PUB_R1_\") {\n        return stringToKey(s.substr(7), KeyType.r1, publicKeyDataSize, \"R1\");\n    } else {\n        throw new Error(\"unrecognized public key format\");\n    }\n}\n\n/** Convert `key` to string (base-58) form */\nexport function publicKeyToString(key: Key) {\n    if (key.type === KeyType.k1 && key.data.length === publicKeyDataSize) {\n        return keyToString(key, \"K1\", \"PUB_K1_\");\n    } else if (key.type === KeyType.r1 && key.data.length === publicKeyDataSize) {\n        return keyToString(key, \"R1\", \"PUB_R1_\");\n    } else {\n        throw new Error(\"unrecognized public key format\");\n    }\n}\n\n/** If a key is in the legacy format (`EOS` prefix), then convert it to the new format (`PUB_K1_`).\n * Leaves other formats untouched\n */\nexport function convertLegacyPublicKey(s: string) {\n    if (s.substr(0, 3) === \"EOS\") {\n        return publicKeyToString(stringToPublicKey(s));\n    }\n    return s;\n}\n\n/** If a key is in the legacy format (`EOS` prefix), then convert it to the new format (`PUB_K1_`).\n * Leaves other formats untouched\n */\nexport function convertLegacyPublicKeys(keys: string[]) {\n    return keys.map(convertLegacyPublicKey);\n}\n\n/** Convert key in `s` to binary form */\nexport function stringToPrivateKey(s: string): Key {\n    if (typeof s !== \"string\") {\n        throw new Error(\"expected string containing private key\");\n    }\n    if (s.substr(0, 7) === \"PVT_R1_\") {\n        return stringToKey(s.substr(7), KeyType.r1, privateKeyDataSize, \"R1\");\n    } else {\n        throw new Error(\"unrecognized private key format\");\n    }\n}\n\n/** Convert `key` to string (base-58) form */\nexport function privateKeyToString(key: Key) {\n    if (key.type === KeyType.r1) {\n        return keyToString(key, \"R1\", \"PVT_R1_\");\n    } else {\n        throw new Error(\"unrecognized private key format\");\n    }\n}\n\n/** Convert key in `s` to binary form */\nexport function stringToSignature(s: string): Key {\n    if (typeof s !== \"string\") {\n        throw new Error(\"expected string containing signature\");\n    }\n    if (s.substr(0, 7) === \"SIG_K1_\") {\n        return stringToKey(s.substr(7), KeyType.k1, signatureDataSize, \"K1\");\n    } else if (s.substr(0, 7) === \"SIG_R1_\") {\n        return stringToKey(s.substr(7), KeyType.r1, signatureDataSize, \"R1\");\n    } else {\n        throw new Error(\"unrecognized signature format\");\n    }\n}\n\n/** Convert `signature` to string (base-58) form */\nexport function signatureToString(signature: Key) {\n    if (signature.type === KeyType.k1) {\n        return keyToString(signature, \"K1\", \"SIG_K1_\");\n    } else if (signature.type === KeyType.r1) {\n        return keyToString(signature, \"R1\", \"SIG_R1_\");\n    } else {\n        throw new Error(\"unrecognized signature format\");\n    }\n}\n","import axios, { AxiosInstance, AxiosRequestConfig } from 'axios'\r\nimport * as ByteBuffer from 'bytebuffer'\r\nimport { AbiProvider, AuthorityProvider, AuthorityProviderArgs, BinaryAbi } from 'eosjs/src/eosjs-api-interfaces'\r\nimport { base64ToBinary, convertLegacyPublicKeys } from 'eosjs/src/eosjs-numeric'\r\nimport {\r\n    Abi,\r\n    GetAbiResult,\r\n    GetBlockResult,\r\n    GetCodeResult,\r\n    GetInfoResult,\r\n    GetRawCodeAndAbiResult,\r\n    PushTransactionArgs\r\n} from 'eosjs/src/eosjs-rpc-interfaces'\r\n\r\nfunction arrayToHex (data: Uint8Array) {\r\n    let result = ''\r\n    for (const x of data) {\r\n        result += ('00' + x.toString(16)).slice(-2)\r\n    }\r\n    return result\r\n}\r\n\r\nexport default class JsonRpc implements AuthorityProvider, AbiProvider {\r\n    public api: AxiosInstance\r\n\r\n    constructor (endpoint: string, args: any = { timeout: 10000 }) {\r\n        const config = {\r\n            baseURL: endpoint,\r\n            timeout: args.timeout\r\n        }\r\n        this.api = axios.create(config as AxiosRequestConfig)\r\n    }\r\n\r\n    // tslint:disable-next-line:variable-name\r\n    public async get_abi (account_name: string): Promise<GetAbiResult> {\r\n        return this.api.get('/v1/eos/contracts/' + account_name).then(r => {\r\n            const abiStr = r.data.abi\r\n            const abi = JSON.parse(abiStr)\r\n            return {\r\n                account_name,\r\n                abi: abi as Abi\r\n            } as GetAbiResult\r\n        })\r\n    }\r\n\r\n    // tslint:disable-next-line:variable-name\r\n    public async get_account (account_name: string): Promise<any> {\r\n        return this.api.get('/v1/eos/accounts/' + account_name).then(r => {\r\n            return r.data\r\n        })\r\n    }\r\n\r\n    // tslint:disable-next-line:variable-name\r\n    public async get_block_header_state (block_num_or_id: number | string): Promise<any> {\r\n        throw new Error('not implemented')\r\n    }\r\n\r\n    // tslint:disable-next-line:variable-name\r\n    public async get_block (block_num_or_id: number | string): Promise<GetBlockResult> {\r\n        let req: any = {}\r\n        if (typeof block_num_or_id === 'number') {\r\n            req = {\r\n                num_start: block_num_or_id,\r\n                num_end: block_num_or_id + 1,\r\n                num_asc: true,\r\n                include_transactions: true\r\n            }\r\n        } else {\r\n            req.id = block_num_or_id\r\n        }\r\n        return this.api.post('/v1/eos/blocks', req).then(r => {\r\n            const block = r.data.blocks[0] // TODO: satisfy GetBlockResult?\r\n            if (block.id) {\r\n                block.ref_block_prefix = ByteBuffer.fromHex(block.id.slice(16, 32),\r\n                                                            ByteBuffer.LITTLE_ENDIAN).readUint32()\r\n            }\r\n            if (block.timestamp && block.timestamp.endsWith('Z')) {\r\n                block.timestamp = block.timestamp.substr(0, block.timestamp.length - 1)\r\n            }\r\n            if (block.num) {\r\n                block.block_num = block.num\r\n            }\r\n            return block\r\n        })\r\n    }\r\n\r\n    // tslint:disable-next-line:variable-name\r\n    public async get_code (account_name: string, code_as_wasm: boolean = false): Promise<GetCodeResult> {\r\n        return this.api.get('/v1/eos/contracts/' + account_name, {\r\n            params: { include_code: true, raw: true, wast: !code_as_wasm }\r\n        }).then(r => {\r\n            const abiStr = r.data.abi\r\n            const abi = JSON.parse(abiStr)\r\n            return {\r\n                account_name,\r\n                abi: abi as Abi,\r\n                wasm: r.data.wasm,\r\n                wast: r.data.wast,\r\n                code_hash: r.data.code_hash\r\n            } as GetCodeResult\r\n        })\r\n    }\r\n\r\n    public async get_currency_balance (code: string, account: string, symbol: string = null): Promise<any> {\r\n        return this.api.get(`/v1/eos/accounts/${account}/balance?contract=${code}&symbol=${symbol}`).then(r => {\r\n            return r.data.balances.map((b: any) => {\r\n                return `${b.balance.toFixed(4)} ${b.symbol}` // TODO: precision may be not 4\r\n            })\r\n        })\r\n    }\r\n\r\n    public async get_currency_stats (code: string, symbol: string): Promise<any> {\r\n        return this.api.post('/v1/eos/currency/stats', {\r\n            currencies: [ { contract: code, symbol } ]\r\n        }).then(r => {\r\n            const stats = r.data.stats[0]\r\n            return {\r\n                [symbol]: {\r\n                    supply: `${stats.supply.toFixed(4)} ${symbol}`,\r\n                    max_supply: `${stats.max_supply.toFixed(4)} ${symbol}`,\r\n                    issuer: stats.issuer\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    public async get_info (): Promise<GetInfoResult> { // TODO: `get_info` returns block which `get_block` can not find\r\n        return this.api.get('/v1/eos/info').then(r => {\r\n            return r.data\r\n        })\r\n    }\r\n\r\n    public async get_producer_schedule (): Promise<any> {\r\n        throw new Error('not implemented')\r\n    }\r\n\r\n    // tslint:disable-next-line:variable-name\r\n    public async get_producers (json = true, lower_bound = '', limit = 50): Promise<any> {\r\n        throw new Error('not implemented')\r\n    }\r\n\r\n    // tslint:disable-next-line:variable-name\r\n    public async get_raw_code_and_abi (account_name: string): Promise<GetRawCodeAndAbiResult> {\r\n        return this.api.get(`/v1/eos/contracts/${account_name}?include_code=true&raw=true`).then(r => {\r\n            return {\r\n                account_name,\r\n                wasm: r.data.wasm,\r\n                abi: r.data.abi\r\n            }\r\n        })\r\n    }\r\n\r\n    public async getRawAbi (accountName: string): Promise<BinaryAbi> {\r\n        const rawCodeAndAbi = await this.get_raw_code_and_abi(accountName)\r\n        const abi = base64ToBinary(rawCodeAndAbi.abi)\r\n        return {\r\n            accountName: rawCodeAndAbi.account_name,\r\n            abi\r\n        }\r\n    }\r\n\r\n    public async get_table_rows ({\r\n        json = true,\r\n        code,\r\n        scope,\r\n        table,\r\n        table_key = '', // TODO: useless?\r\n        lower_bound = '',\r\n        upper_bound = '',\r\n        limit = 10 }: any): Promise<any> {\r\n        return this.api.post('/v1/eos/table', {\r\n            code, scope, table, lower_bound, upper_bound, limit,\r\n            binary: !json\r\n        }).then(r => {\r\n            return r.data\r\n        })\r\n    }\r\n\r\n    /** Get subset of `availableKeys` needed to meet authorities in `transaction`. Implements `AuthorityProvider` */\r\n    public async getRequiredKeys (args: AuthorityProviderArgs): Promise<string[]> {\r\n        const transaction = JSON.stringify(args.transaction)\r\n        return this.api.post('/v1/eos/required-keys', {\r\n            transaction,\r\n            available_keys: args.availableKeys,\r\n        }).then(r => {\r\n            return convertLegacyPublicKeys(r.data.required_keys)\r\n        })\r\n    }\r\n\r\n    /** Push a serialized transaction */\r\n    public async push_transaction ({ signatures, serializedTransaction }: PushTransactionArgs): Promise<any> {\r\n        return this.api.post('/v1/eos/txs', {\r\n            tx: JSON.stringify({\r\n                signatures,\r\n                packed_trx: arrayToHex(serializedTransaction)\r\n            })\r\n        }).then(r => {\r\n            return {\r\n                transaction_id: r.data.tx_id // TODO: other fields\r\n            }\r\n        })\r\n    }\r\n\r\n    public async db_size_get () {\r\n        throw new Error('not implemented')\r\n    }\r\n\r\n    // tslint:disable-next-line:variable-name\r\n    public async history_get_actions (account_name: string, pos: number = null, offset: number = null) {\r\n        throw new Error('not implemented')\r\n    }\r\n\r\n    // tslint:disable-next-line:variable-name\r\n    public async history_get_transaction (id: string, block_num_hint: number = null) {\r\n        throw new Error('not implemented')\r\n    }\r\n\r\n    // tslint:disable-next-line:variable-name\r\n    public async history_get_key_accounts (public_key: string) {\r\n        return this.api.get(`/v1/eos/accounts-for-key?public_key=${public_key}`).then(r => {\r\n            return {\r\n                account_names: r.data.accounts\r\n            }\r\n        })\r\n    }\r\n\r\n    // tslint:disable-next-line:variable-name\r\n    public async history_get_controlled_accounts (controlling_account: string) {\r\n        throw new Error('not implemented') // TODO\r\n    }\r\n}\r\n","module.exports = require('./lib/axios');","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(utils.merge(defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","'use strict';\n\nvar defaults = require('./../defaults');\nvar utils = require('./../utils');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = utils.merge({\n      url: arguments[0]\n    }, arguments[1]);\n  }\n\n  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);\n  config.method = config.method.toLowerCase();\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  // Note: status is not exposed by XDomainRequest\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n  error.request = request;\n  error.response = response;\n  return error;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    var msie = /(msie|trident)/i.test(navigator.userAgent);\n    var urlParsingNode = document.createElement('a');\n    var originURL;\n\n    /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      var href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n                  urlParsingNode.pathname :\n                  '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })()\n);\n","'use strict';\n\n// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction E() {\n  this.message = 'String contains an invalid character';\n}\nE.prototype = new Error;\nE.prototype.code = 5;\nE.prototype.name = 'InvalidCharacterError';\n\nfunction btoa(input) {\n  var str = String(input);\n  var output = '';\n  for (\n    // initialize result and counter\n    var block, charCode, idx = 0, map = chars;\n    // if the next str index does not exist:\n    //   change the mapping table to \"=\"\n    //   check if d has no fractional digits\n    str.charAt(idx | 0) || (map = '=', idx % 1);\n    // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n    output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n  ) {\n    charCode = str.charCodeAt(idx += 3 / 4);\n    if (charCode > 0xFF) {\n      throw new E();\n    }\n    block = block << 8 | charCode;\n  }\n  return output;\n}\n\nmodule.exports = btoa;\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n  (function standardBrowserEnv() {\n    return {\n      write: function write(name, value, expires, path, domain, secure) {\n        var cookie = [];\n        cookie.push(name + '=' + encodeURIComponent(value));\n\n        if (utils.isNumber(expires)) {\n          cookie.push('expires=' + new Date(expires).toGMTString());\n        }\n\n        if (utils.isString(path)) {\n          cookie.push('path=' + path);\n        }\n\n        if (utils.isString(domain)) {\n          cookie.push('domain=' + domain);\n        }\n\n        if (secure === true) {\n          cookie.push('secure');\n        }\n\n        document.cookie = cookie.join('; ');\n      },\n\n      read: function read(name) {\n        var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n        return (match ? decodeURIComponent(match[3]) : null);\n      },\n\n      remove: function remove(name) {\n        this.write(name, '', Date.now() - 86400000);\n      }\n    };\n  })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return {\n      write: function write() {},\n      read: function read() { return null; },\n      remove: function remove() {}\n    };\n  })()\n);\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\nvar isAbsoluteURL = require('./../helpers/isAbsoluteURL');\nvar combineURLs = require('./../helpers/combineURLs');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Support baseURL config\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers || {}\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n","/*\r\n Copyright 2013 Daniel Wirtz <dcode@dcode.io>\r\n Copyright 2009 The Closure Library Authors. All Rights Reserved.\r\n\r\n Licensed under the Apache License, Version 2.0 (the \"License\");\r\n you may not use this file except in compliance with the License.\r\n You may obtain a copy of the License at\r\n\r\n http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n Unless required by applicable law or agreed to in writing, software\r\n distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n See the License for the specific language governing permissions and\r\n limitations under the License.\r\n */\r\n\r\n/**\r\n * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>\r\n * Released under the Apache License, Version 2.0\r\n * see: https://github.com/dcodeIO/long.js for details\r\n */\r\n(function(global, factory) {\r\n\r\n    /* AMD */ if (typeof define === 'function' && define[\"amd\"])\r\n        define([], factory);\r\n    /* CommonJS */ else if (typeof require === 'function' && typeof module === \"object\" && module && module[\"exports\"])\r\n        module[\"exports\"] = factory();\r\n    /* Global */ else\r\n        (global[\"dcodeIO\"] = global[\"dcodeIO\"] || {})[\"Long\"] = factory();\r\n\r\n})(this, function() {\r\n    \"use strict\";\r\n\r\n    /**\r\n     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n     *  See the from* functions below for more convenient ways of constructing Longs.\r\n     * @exports Long\r\n     * @class A Long class for representing a 64 bit two's-complement integer value.\r\n     * @param {number} low The low (signed) 32 bits of the long\r\n     * @param {number} high The high (signed) 32 bits of the long\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @constructor\r\n     */\r\n    function Long(low, high, unsigned) {\r\n\r\n        /**\r\n         * The low 32 bits as a signed value.\r\n         * @type {number}\r\n         */\r\n        this.low = low | 0;\r\n\r\n        /**\r\n         * The high 32 bits as a signed value.\r\n         * @type {number}\r\n         */\r\n        this.high = high | 0;\r\n\r\n        /**\r\n         * Whether unsigned or not.\r\n         * @type {boolean}\r\n         */\r\n        this.unsigned = !!unsigned;\r\n    }\r\n\r\n    // The internal representation of a long is the two given signed, 32-bit values.\r\n    // We use 32-bit pieces because these are the size of integers on which\r\n    // Javascript performs bit-operations.  For operations like addition and\r\n    // multiplication, we split each number into 16 bit pieces, which can easily be\r\n    // multiplied within Javascript's floating-point representation without overflow\r\n    // or change in sign.\r\n    //\r\n    // In the algorithms below, we frequently reduce the negative case to the\r\n    // positive case by negating the input(s) and then post-processing the result.\r\n    // Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n    // a positive number, it overflows back into a negative).  Not handling this\r\n    // case would often result in infinite recursion.\r\n    //\r\n    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n    // methods on which they depend.\r\n\r\n    /**\r\n     * An indicator used to reliably determine if an object is a Long or not.\r\n     * @type {boolean}\r\n     * @const\r\n     * @private\r\n     */\r\n    Long.prototype.__isLong__;\r\n\r\n    Object.defineProperty(Long.prototype, \"__isLong__\", {\r\n        value: true,\r\n        enumerable: false,\r\n        configurable: false\r\n    });\r\n\r\n    /**\r\n     * @function\r\n     * @param {*} obj Object\r\n     * @returns {boolean}\r\n     * @inner\r\n     */\r\n    function isLong(obj) {\r\n        return (obj && obj[\"__isLong__\"]) === true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the specified object is a Long.\r\n     * @function\r\n     * @param {*} obj Object\r\n     * @returns {boolean}\r\n     */\r\n    Long.isLong = isLong;\r\n\r\n    /**\r\n     * A cache of the Long representations of small integer values.\r\n     * @type {!Object}\r\n     * @inner\r\n     */\r\n    var INT_CACHE = {};\r\n\r\n    /**\r\n     * A cache of the Long representations of small unsigned integer values.\r\n     * @type {!Object}\r\n     * @inner\r\n     */\r\n    var UINT_CACHE = {};\r\n\r\n    /**\r\n     * @param {number} value\r\n     * @param {boolean=} unsigned\r\n     * @returns {!Long}\r\n     * @inner\r\n     */\r\n    function fromInt(value, unsigned) {\r\n        var obj, cachedObj, cache;\r\n        if (unsigned) {\r\n            value >>>= 0;\r\n            if (cache = (0 <= value && value < 256)) {\r\n                cachedObj = UINT_CACHE[value];\r\n                if (cachedObj)\r\n                    return cachedObj;\r\n            }\r\n            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n            if (cache)\r\n                UINT_CACHE[value] = obj;\r\n            return obj;\r\n        } else {\r\n            value |= 0;\r\n            if (cache = (-128 <= value && value < 128)) {\r\n                cachedObj = INT_CACHE[value];\r\n                if (cachedObj)\r\n                    return cachedObj;\r\n            }\r\n            obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n            if (cache)\r\n                INT_CACHE[value] = obj;\r\n            return obj;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a Long representing the given 32 bit integer value.\r\n     * @function\r\n     * @param {number} value The 32 bit integer in question\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @returns {!Long} The corresponding Long value\r\n     */\r\n    Long.fromInt = fromInt;\r\n\r\n    /**\r\n     * @param {number} value\r\n     * @param {boolean=} unsigned\r\n     * @returns {!Long}\r\n     * @inner\r\n     */\r\n    function fromNumber(value, unsigned) {\r\n        if (isNaN(value) || !isFinite(value))\r\n            return unsigned ? UZERO : ZERO;\r\n        if (unsigned) {\r\n            if (value < 0)\r\n                return UZERO;\r\n            if (value >= TWO_PWR_64_DBL)\r\n                return MAX_UNSIGNED_VALUE;\r\n        } else {\r\n            if (value <= -TWO_PWR_63_DBL)\r\n                return MIN_VALUE;\r\n            if (value + 1 >= TWO_PWR_63_DBL)\r\n                return MAX_VALUE;\r\n        }\r\n        if (value < 0)\r\n            return fromNumber(-value, unsigned).neg();\r\n        return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n    }\r\n\r\n    /**\r\n     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n     * @function\r\n     * @param {number} value The number in question\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @returns {!Long} The corresponding Long value\r\n     */\r\n    Long.fromNumber = fromNumber;\r\n\r\n    /**\r\n     * @param {number} lowBits\r\n     * @param {number} highBits\r\n     * @param {boolean=} unsigned\r\n     * @returns {!Long}\r\n     * @inner\r\n     */\r\n    function fromBits(lowBits, highBits, unsigned) {\r\n        return new Long(lowBits, highBits, unsigned);\r\n    }\r\n\r\n    /**\r\n     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n     *  assumed to use 32 bits.\r\n     * @function\r\n     * @param {number} lowBits The low 32 bits\r\n     * @param {number} highBits The high 32 bits\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @returns {!Long} The corresponding Long value\r\n     */\r\n    Long.fromBits = fromBits;\r\n\r\n    /**\r\n     * @function\r\n     * @param {number} base\r\n     * @param {number} exponent\r\n     * @returns {number}\r\n     * @inner\r\n     */\r\n    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n    /**\r\n     * @param {string} str\r\n     * @param {(boolean|number)=} unsigned\r\n     * @param {number=} radix\r\n     * @returns {!Long}\r\n     * @inner\r\n     */\r\n    function fromString(str, unsigned, radix) {\r\n        if (str.length === 0)\r\n            throw Error('empty string');\r\n        if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n            return ZERO;\r\n        if (typeof unsigned === 'number') {\r\n            // For goog.math.long compatibility\r\n            radix = unsigned,\r\n            unsigned = false;\r\n        } else {\r\n            unsigned = !! unsigned;\r\n        }\r\n        radix = radix || 10;\r\n        if (radix < 2 || 36 < radix)\r\n            throw RangeError('radix');\r\n\r\n        var p;\r\n        if ((p = str.indexOf('-')) > 0)\r\n            throw Error('interior hyphen');\r\n        else if (p === 0) {\r\n            return fromString(str.substring(1), unsigned, radix).neg();\r\n        }\r\n\r\n        // Do several (8) digits each time through the loop, so as to\r\n        // minimize the calls to the very expensive emulated div.\r\n        var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n        var result = ZERO;\r\n        for (var i = 0; i < str.length; i += 8) {\r\n            var size = Math.min(8, str.length - i),\r\n                value = parseInt(str.substring(i, i + size), radix);\r\n            if (size < 8) {\r\n                var power = fromNumber(pow_dbl(radix, size));\r\n                result = result.mul(power).add(fromNumber(value));\r\n            } else {\r\n                result = result.mul(radixToPower);\r\n                result = result.add(fromNumber(value));\r\n            }\r\n        }\r\n        result.unsigned = unsigned;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a Long representation of the given string, written using the specified radix.\r\n     * @function\r\n     * @param {string} str The textual representation of the Long\r\n     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n     * @returns {!Long} The corresponding Long value\r\n     */\r\n    Long.fromString = fromString;\r\n\r\n    /**\r\n     * @function\r\n     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n     * @returns {!Long}\r\n     * @inner\r\n     */\r\n    function fromValue(val) {\r\n        if (val /* is compatible */ instanceof Long)\r\n            return val;\r\n        if (typeof val === 'number')\r\n            return fromNumber(val);\r\n        if (typeof val === 'string')\r\n            return fromString(val);\r\n        // Throws for non-objects, converts non-instanceof Long:\r\n        return fromBits(val.low, val.high, val.unsigned);\r\n    }\r\n\r\n    /**\r\n     * Converts the specified value to a Long.\r\n     * @function\r\n     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n     * @returns {!Long}\r\n     */\r\n    Long.fromValue = fromValue;\r\n\r\n    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n    // no runtime penalty for these.\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_16_DBL = 1 << 16;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_24_DBL = 1 << 24;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var ZERO = fromInt(0);\r\n\r\n    /**\r\n     * Signed zero.\r\n     * @type {!Long}\r\n     */\r\n    Long.ZERO = ZERO;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var UZERO = fromInt(0, true);\r\n\r\n    /**\r\n     * Unsigned zero.\r\n     * @type {!Long}\r\n     */\r\n    Long.UZERO = UZERO;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var ONE = fromInt(1);\r\n\r\n    /**\r\n     * Signed one.\r\n     * @type {!Long}\r\n     */\r\n    Long.ONE = ONE;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var UONE = fromInt(1, true);\r\n\r\n    /**\r\n     * Unsigned one.\r\n     * @type {!Long}\r\n     */\r\n    Long.UONE = UONE;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var NEG_ONE = fromInt(-1);\r\n\r\n    /**\r\n     * Signed negative one.\r\n     * @type {!Long}\r\n     */\r\n    Long.NEG_ONE = NEG_ONE;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n    /**\r\n     * Maximum signed value.\r\n     * @type {!Long}\r\n     */\r\n    Long.MAX_VALUE = MAX_VALUE;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n    /**\r\n     * Maximum unsigned value.\r\n     * @type {!Long}\r\n     */\r\n    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n    /**\r\n     * Minimum signed value.\r\n     * @type {!Long}\r\n     */\r\n    Long.MIN_VALUE = MIN_VALUE;\r\n\r\n    /**\r\n     * @alias Long.prototype\r\n     * @inner\r\n     */\r\n    var LongPrototype = Long.prototype;\r\n\r\n    /**\r\n     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n     * @returns {number}\r\n     */\r\n    LongPrototype.toInt = function toInt() {\r\n        return this.unsigned ? this.low >>> 0 : this.low;\r\n    };\r\n\r\n    /**\r\n     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n     * @returns {number}\r\n     */\r\n    LongPrototype.toNumber = function toNumber() {\r\n        if (this.unsigned)\r\n            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n    };\r\n\r\n    /**\r\n     * Converts the Long to a string written in the specified radix.\r\n     * @param {number=} radix Radix (2-36), defaults to 10\r\n     * @returns {string}\r\n     * @override\r\n     * @throws {RangeError} If `radix` is out of range\r\n     */\r\n    LongPrototype.toString = function toString(radix) {\r\n        radix = radix || 10;\r\n        if (radix < 2 || 36 < radix)\r\n            throw RangeError('radix');\r\n        if (this.isZero())\r\n            return '0';\r\n        if (this.isNegative()) { // Unsigned Longs are never negative\r\n            if (this.eq(MIN_VALUE)) {\r\n                // We need to change the Long value before it can be negated, so we remove\r\n                // the bottom-most digit in this base and then recurse to do the rest.\r\n                var radixLong = fromNumber(radix),\r\n                    div = this.div(radixLong),\r\n                    rem1 = div.mul(radixLong).sub(this);\r\n                return div.toString(radix) + rem1.toInt().toString(radix);\r\n            } else\r\n                return '-' + this.neg().toString(radix);\r\n        }\r\n\r\n        // Do several (6) digits each time through the loop, so as to\r\n        // minimize the calls to the very expensive emulated div.\r\n        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n            rem = this;\r\n        var result = '';\r\n        while (true) {\r\n            var remDiv = rem.div(radixToPower),\r\n                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n                digits = intval.toString(radix);\r\n            rem = remDiv;\r\n            if (rem.isZero())\r\n                return digits + result;\r\n            else {\r\n                while (digits.length < 6)\r\n                    digits = '0' + digits;\r\n                result = '' + digits + result;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets the high 32 bits as a signed integer.\r\n     * @returns {number} Signed high bits\r\n     */\r\n    LongPrototype.getHighBits = function getHighBits() {\r\n        return this.high;\r\n    };\r\n\r\n    /**\r\n     * Gets the high 32 bits as an unsigned integer.\r\n     * @returns {number} Unsigned high bits\r\n     */\r\n    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n        return this.high >>> 0;\r\n    };\r\n\r\n    /**\r\n     * Gets the low 32 bits as a signed integer.\r\n     * @returns {number} Signed low bits\r\n     */\r\n    LongPrototype.getLowBits = function getLowBits() {\r\n        return this.low;\r\n    };\r\n\r\n    /**\r\n     * Gets the low 32 bits as an unsigned integer.\r\n     * @returns {number} Unsigned low bits\r\n     */\r\n    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n        return this.low >>> 0;\r\n    };\r\n\r\n    /**\r\n     * Gets the number of bits needed to represent the absolute value of this Long.\r\n     * @returns {number}\r\n     */\r\n    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n        if (this.isNegative()) // Unsigned Longs are never negative\r\n            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n        var val = this.high != 0 ? this.high : this.low;\r\n        for (var bit = 31; bit > 0; bit--)\r\n            if ((val & (1 << bit)) != 0)\r\n                break;\r\n        return this.high != 0 ? bit + 33 : bit + 1;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value equals zero.\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.isZero = function isZero() {\r\n        return this.high === 0 && this.low === 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is negative.\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.isNegative = function isNegative() {\r\n        return !this.unsigned && this.high < 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is positive.\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.isPositive = function isPositive() {\r\n        return this.unsigned || this.high >= 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is odd.\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.isOdd = function isOdd() {\r\n        return (this.low & 1) === 1;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is even.\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.isEven = function isEven() {\r\n        return (this.low & 1) === 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value equals the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.equals = function equals(other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n            return false;\r\n        return this.high === other.high && this.low === other.low;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.eq = LongPrototype.equals;\r\n\r\n    /**\r\n     * Tests if this Long's value differs from the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.notEquals = function notEquals(other) {\r\n        return !this.eq(/* validates */ other);\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.neq = LongPrototype.notEquals;\r\n\r\n    /**\r\n     * Tests if this Long's value is less than the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.lessThan = function lessThan(other) {\r\n        return this.comp(/* validates */ other) < 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.lt = LongPrototype.lessThan;\r\n\r\n    /**\r\n     * Tests if this Long's value is less than or equal the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n        return this.comp(/* validates */ other) <= 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.greaterThan = function greaterThan(other) {\r\n        return this.comp(/* validates */ other) > 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than or equal the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n        return this.comp(/* validates */ other) >= 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n    /**\r\n     * Compares this Long's value with the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n     *  if the given one is greater\r\n     */\r\n    LongPrototype.compare = function compare(other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        if (this.eq(other))\r\n            return 0;\r\n        var thisNeg = this.isNegative(),\r\n            otherNeg = other.isNegative();\r\n        if (thisNeg && !otherNeg)\r\n            return -1;\r\n        if (!thisNeg && otherNeg)\r\n            return 1;\r\n        // At this point the sign bits are the same\r\n        if (!this.unsigned)\r\n            return this.sub(other).isNegative() ? -1 : 1;\r\n        // Both are positive if at least one is unsigned\r\n        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n    };\r\n\r\n    /**\r\n     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n     *  if the given one is greater\r\n     */\r\n    LongPrototype.comp = LongPrototype.compare;\r\n\r\n    /**\r\n     * Negates this Long's value.\r\n     * @returns {!Long} Negated Long\r\n     */\r\n    LongPrototype.negate = function negate() {\r\n        if (!this.unsigned && this.eq(MIN_VALUE))\r\n            return MIN_VALUE;\r\n        return this.not().add(ONE);\r\n    };\r\n\r\n    /**\r\n     * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n     * @function\r\n     * @returns {!Long} Negated Long\r\n     */\r\n    LongPrototype.neg = LongPrototype.negate;\r\n\r\n    /**\r\n     * Returns the sum of this and the specified Long.\r\n     * @param {!Long|number|string} addend Addend\r\n     * @returns {!Long} Sum\r\n     */\r\n    LongPrototype.add = function add(addend) {\r\n        if (!isLong(addend))\r\n            addend = fromValue(addend);\r\n\r\n        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n        var a48 = this.high >>> 16;\r\n        var a32 = this.high & 0xFFFF;\r\n        var a16 = this.low >>> 16;\r\n        var a00 = this.low & 0xFFFF;\r\n\r\n        var b48 = addend.high >>> 16;\r\n        var b32 = addend.high & 0xFFFF;\r\n        var b16 = addend.low >>> 16;\r\n        var b00 = addend.low & 0xFFFF;\r\n\r\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n        c00 += a00 + b00;\r\n        c16 += c00 >>> 16;\r\n        c00 &= 0xFFFF;\r\n        c16 += a16 + b16;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c32 += a32 + b32;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c48 += a48 + b48;\r\n        c48 &= 0xFFFF;\r\n        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the difference of this and the specified Long.\r\n     * @param {!Long|number|string} subtrahend Subtrahend\r\n     * @returns {!Long} Difference\r\n     */\r\n    LongPrototype.subtract = function subtract(subtrahend) {\r\n        if (!isLong(subtrahend))\r\n            subtrahend = fromValue(subtrahend);\r\n        return this.add(subtrahend.neg());\r\n    };\r\n\r\n    /**\r\n     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n     * @function\r\n     * @param {!Long|number|string} subtrahend Subtrahend\r\n     * @returns {!Long} Difference\r\n     */\r\n    LongPrototype.sub = LongPrototype.subtract;\r\n\r\n    /**\r\n     * Returns the product of this and the specified Long.\r\n     * @param {!Long|number|string} multiplier Multiplier\r\n     * @returns {!Long} Product\r\n     */\r\n    LongPrototype.multiply = function multiply(multiplier) {\r\n        if (this.isZero())\r\n            return ZERO;\r\n        if (!isLong(multiplier))\r\n            multiplier = fromValue(multiplier);\r\n        if (multiplier.isZero())\r\n            return ZERO;\r\n        if (this.eq(MIN_VALUE))\r\n            return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n        if (multiplier.eq(MIN_VALUE))\r\n            return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n        if (this.isNegative()) {\r\n            if (multiplier.isNegative())\r\n                return this.neg().mul(multiplier.neg());\r\n            else\r\n                return this.neg().mul(multiplier).neg();\r\n        } else if (multiplier.isNegative())\r\n            return this.mul(multiplier.neg()).neg();\r\n\r\n        // If both longs are small, use float multiplication\r\n        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n        // We can skip products that would overflow.\r\n\r\n        var a48 = this.high >>> 16;\r\n        var a32 = this.high & 0xFFFF;\r\n        var a16 = this.low >>> 16;\r\n        var a00 = this.low & 0xFFFF;\r\n\r\n        var b48 = multiplier.high >>> 16;\r\n        var b32 = multiplier.high & 0xFFFF;\r\n        var b16 = multiplier.low >>> 16;\r\n        var b00 = multiplier.low & 0xFFFF;\r\n\r\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n        c00 += a00 * b00;\r\n        c16 += c00 >>> 16;\r\n        c00 &= 0xFFFF;\r\n        c16 += a16 * b00;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c16 += a00 * b16;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c32 += a32 * b00;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c32 += a16 * b16;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c32 += a00 * b32;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n        c48 &= 0xFFFF;\r\n        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n     * @function\r\n     * @param {!Long|number|string} multiplier Multiplier\r\n     * @returns {!Long} Product\r\n     */\r\n    LongPrototype.mul = LongPrototype.multiply;\r\n\r\n    /**\r\n     * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n     *  unsigned if this Long is unsigned.\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Quotient\r\n     */\r\n    LongPrototype.divide = function divide(divisor) {\r\n        if (!isLong(divisor))\r\n            divisor = fromValue(divisor);\r\n        if (divisor.isZero())\r\n            throw Error('division by zero');\r\n        if (this.isZero())\r\n            return this.unsigned ? UZERO : ZERO;\r\n        var approx, rem, res;\r\n        if (!this.unsigned) {\r\n            // This section is only relevant for signed longs and is derived from the\r\n            // closure library as a whole.\r\n            if (this.eq(MIN_VALUE)) {\r\n                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                    return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n                else if (divisor.eq(MIN_VALUE))\r\n                    return ONE;\r\n                else {\r\n                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                    var halfThis = this.shr(1);\r\n                    approx = halfThis.div(divisor).shl(1);\r\n                    if (approx.eq(ZERO)) {\r\n                        return divisor.isNegative() ? ONE : NEG_ONE;\r\n                    } else {\r\n                        rem = this.sub(divisor.mul(approx));\r\n                        res = approx.add(rem.div(divisor));\r\n                        return res;\r\n                    }\r\n                }\r\n            } else if (divisor.eq(MIN_VALUE))\r\n                return this.unsigned ? UZERO : ZERO;\r\n            if (this.isNegative()) {\r\n                if (divisor.isNegative())\r\n                    return this.neg().div(divisor.neg());\r\n                return this.neg().div(divisor).neg();\r\n            } else if (divisor.isNegative())\r\n                return this.div(divisor.neg()).neg();\r\n            res = ZERO;\r\n        } else {\r\n            // The algorithm below has not been made for unsigned longs. It's therefore\r\n            // required to take special care of the MSB prior to running it.\r\n            if (!divisor.unsigned)\r\n                divisor = divisor.toUnsigned();\r\n            if (divisor.gt(this))\r\n                return UZERO;\r\n            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n                return UONE;\r\n            res = UZERO;\r\n        }\r\n\r\n        // Repeat the following until the remainder is less than other:  find a\r\n        // floating-point that approximates remainder / other *from below*, add this\r\n        // into the result, and subtract it from the remainder.  It is critical that\r\n        // the approximate value is less than or equal to the real value so that the\r\n        // remainder never becomes negative.\r\n        rem = this;\r\n        while (rem.gte(divisor)) {\r\n            // Approximate the result of division. This may be a little greater or\r\n            // smaller than the actual value.\r\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n            // We will tweak the approximate result by changing it in the 48-th digit or\r\n            // the smallest non-fractional digit, whichever is larger.\r\n            var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n                delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n            // Decrease the approximation until it is smaller than the remainder.  Note\r\n            // that if it is too large, the product overflows and is negative.\r\n                approxRes = fromNumber(approx),\r\n                approxRem = approxRes.mul(divisor);\r\n            while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n                approx -= delta;\r\n                approxRes = fromNumber(approx, this.unsigned);\r\n                approxRem = approxRes.mul(divisor);\r\n            }\r\n\r\n            // We know the answer can't be zero... and actually, zero would cause\r\n            // infinite recursion since we would make no progress.\r\n            if (approxRes.isZero())\r\n                approxRes = ONE;\r\n\r\n            res = res.add(approxRes);\r\n            rem = rem.sub(approxRem);\r\n        }\r\n        return res;\r\n    };\r\n\r\n    /**\r\n     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n     * @function\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Quotient\r\n     */\r\n    LongPrototype.div = LongPrototype.divide;\r\n\r\n    /**\r\n     * Returns this Long modulo the specified.\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Remainder\r\n     */\r\n    LongPrototype.modulo = function modulo(divisor) {\r\n        if (!isLong(divisor))\r\n            divisor = fromValue(divisor);\r\n        return this.sub(this.div(divisor).mul(divisor));\r\n    };\r\n\r\n    /**\r\n     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n     * @function\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Remainder\r\n     */\r\n    LongPrototype.mod = LongPrototype.modulo;\r\n\r\n    /**\r\n     * Returns the bitwise NOT of this Long.\r\n     * @returns {!Long}\r\n     */\r\n    LongPrototype.not = function not() {\r\n        return fromBits(~this.low, ~this.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the bitwise AND of this Long and the specified.\r\n     * @param {!Long|number|string} other Other Long\r\n     * @returns {!Long}\r\n     */\r\n    LongPrototype.and = function and(other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the bitwise OR of this Long and the specified.\r\n     * @param {!Long|number|string} other Other Long\r\n     * @returns {!Long}\r\n     */\r\n    LongPrototype.or = function or(other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the bitwise XOR of this Long and the given one.\r\n     * @param {!Long|number|string} other Other Long\r\n     * @returns {!Long}\r\n     */\r\n    LongPrototype.xor = function xor(other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits shifted to the left by the given amount.\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        if ((numBits &= 63) === 0)\r\n            return this;\r\n        else if (numBits < 32)\r\n            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n        else\r\n            return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n     * @function\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n    /**\r\n     * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shiftRight = function shiftRight(numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        if ((numBits &= 63) === 0)\r\n            return this;\r\n        else if (numBits < 32)\r\n            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n        else\r\n            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n     * @function\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n    /**\r\n     * Returns this Long with bits logically shifted to the right by the given amount.\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        numBits &= 63;\r\n        if (numBits === 0)\r\n            return this;\r\n        else {\r\n            var high = this.high;\r\n            if (numBits < 32) {\r\n                var low = this.low;\r\n                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n            } else if (numBits === 32)\r\n                return fromBits(high, 0, this.unsigned);\r\n            else\r\n                return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n     * @function\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n    /**\r\n     * Converts this Long to signed.\r\n     * @returns {!Long} Signed long\r\n     */\r\n    LongPrototype.toSigned = function toSigned() {\r\n        if (!this.unsigned)\r\n            return this;\r\n        return fromBits(this.low, this.high, false);\r\n    };\r\n\r\n    /**\r\n     * Converts this Long to unsigned.\r\n     * @returns {!Long} Unsigned long\r\n     */\r\n    LongPrototype.toUnsigned = function toUnsigned() {\r\n        if (this.unsigned)\r\n            return this;\r\n        return fromBits(this.low, this.high, true);\r\n    };\r\n\r\n    /**\r\n     * Converts this Long to its byte representation.\r\n     * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n     * @returns {!Array.<number>} Byte representation\r\n     */\r\n    LongPrototype.toBytes = function(le) {\r\n        return le ? this.toBytesLE() : this.toBytesBE();\r\n    }\r\n\r\n    /**\r\n     * Converts this Long to its little endian byte representation.\r\n     * @returns {!Array.<number>} Little endian byte representation\r\n     */\r\n    LongPrototype.toBytesLE = function() {\r\n        var hi = this.high,\r\n            lo = this.low;\r\n        return [\r\n             lo         & 0xff,\r\n            (lo >>>  8) & 0xff,\r\n            (lo >>> 16) & 0xff,\r\n            (lo >>> 24) & 0xff,\r\n             hi         & 0xff,\r\n            (hi >>>  8) & 0xff,\r\n            (hi >>> 16) & 0xff,\r\n            (hi >>> 24) & 0xff\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Converts this Long to its big endian byte representation.\r\n     * @returns {!Array.<number>} Big endian byte representation\r\n     */\r\n    LongPrototype.toBytesBE = function() {\r\n        var hi = this.high,\r\n            lo = this.low;\r\n        return [\r\n            (hi >>> 24) & 0xff,\r\n            (hi >>> 16) & 0xff,\r\n            (hi >>>  8) & 0xff,\r\n             hi         & 0xff,\r\n            (lo >>> 24) & 0xff,\r\n            (lo >>> 16) & 0xff,\r\n            (lo >>>  8) & 0xff,\r\n             lo         & 0xff\r\n        ];\r\n    }\r\n\r\n    return Long;\r\n});\r\n","// https://gist.githubusercontent.com/wlzla000/bac83df6d3c51916c4dd0bc947e46947/raw/7ee3462b095ab22580ddaf191f44a590da6fe33b/RIPEMD-160.js\n\n/*\n\tRIPEMD-160.js\n\n\t\tdeveloped\n\t\t\tby K. (https://github.com/wlzla000)\n\t\t\ton December 27-29, 2017,\n\n\t\tlicensed under\n\n\n\t\tthe MIT license\n\n\t\tCopyright (c) 2017 K.\n\n\t\t Permission is hereby granted, free of charge, to any person\n\t\tobtaining a copy of this software and associated documentation\n\t\tfiles (the \"Software\"), to deal in the Software without\n\t\trestriction, including without limitation the rights to use,\n\t\tcopy, modify, merge, publish, distribute, sublicense, and/or\n\t\tsell copies of the Software, and to permit persons to whom the\n\t\tSoftware is furnished to do so, subject to the following\n\t\tconditions:\n\n\t\t The above copyright notice and this permission notice shall be\n\t\tincluded in all copies or substantial portions of the Software.\n\n\t\t THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n\t\tEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n\t\tOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n\t\tNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n\t\tHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n\t\tWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n\t\tFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n\t\tOTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\"use strict\";\n\nclass RIPEMD160\n{\n\tconstructor()\n\t{\n\t\t// https://webcache.googleusercontent.com/search?q=cache:CnLOgolTHYEJ:https://www.cosic.esat.kuleuven.be/publications/article-317.pdf\n\t\t// http://shodhganga.inflibnet.ac.in/bitstream/10603/22978/13/13_appendix.pdf\n\t}\n\n\tstatic get_n_pad_bytes(message_size /* in bytes, 1 byte is 8 bits. */)\n\t{\n\t\t//  Obtain the number of bytes needed to pad the message.\n\t\t// It does not contain the size of the message size information.\n\t\t/*\n\t\t\thttps://webcache.googleusercontent.com/search?q=cache:CnLOgolTHYEJ:https://www.cosic.esat.kuleuven.be/publications/article-317.pdf\n\n\t\t\tThe Cryptographic Hash Function RIPEMD-160\n\n\t\t\twritten by\n\t\t\t\tBart Preneel,\n\t\t\t\tHans Dobbertin,\n\t\t\t\tAntoon Bosselaers\n\t\t\tin\n\t\t\t\t1997.\n\n\t\t\t--------------------------------------------------\n\n\t\t\t5     Description of RIPEMD-160\n\n\t\t\t......\n\n\t\t\t In order to guarantee that the total input size is a\n\t\t\tmultiple of 512 bits, the input is padded in the same\n\t\t\tway as for all the members of the MD4-family: one\n\t\t\tappends a single 1 followed by a string of 0s (the\n\t\t\tnumber of 0s lies between 0 and 511); the last 64 bits\n\t\t\tof the extended input contain the binary representation\n\t\t\tof the input size in bits, least significant byte first.\n\t\t*/\n\t\t/*\n\t\t\thttps://tools.ietf.org/rfc/rfc1186.txt\n\n\t\t\tRFC 1186: MD4 Message Digest Algorithm.\n\n\t\t\twritten by\n\t\t\t\tRonald Linn Rivest\n\t\t\tin\n\t\t\t\tOctober 1990.\n\n\t\t\t--------------------------------------------------\n\n\t\t\t3     MD4 Algorithm Description\n\n\t\t\t......\n\n\t\t\tStep 1. Append padding bits\n\n\t\t\t The message is \"padded\" (extended) so that its length\n\t\t\t(in bits) is congruent to 448, modulo 512. That is, the\n\t\t\tmessage is extended so that it is just 64 bits shy of\n\t\t\tbeing a multiple of 512 bits long. Padding is always\n\t\t\tperformed, even if the length of the message is already\n\t\t\tcongruent to 448, modulo 512 (in which case 512 bits of\n\t\t\tpadding are added).\n\n\t\t\t Padding is performed as follows: a single \"1\" bit is\n\t\t\tappended to the message, and then enough zero bits are\n\t\t\tappended so that the length in bits of the padded\n\t\t\tmessage becomes congruent to 448, modulo 512.\n\n\t\t\tStep 2. Append length\n\n\t\t\t A 64-bit representation of b (the length of the message\n\t\t\tbefore the padding bits were added) is appended to the\n\t\t\tresult of the previous step. In the unlikely event that\n\t\t\tb is greater than 2^64, then only the low-order 64 bits\n\t\t\tof b are used. (These bits are appended as two 32-bit\n\t\t\twords and appended low-order word first in accordance\n\t\t\twith the previous conventions.)\n\n\t\t\t At this point the resulting message (after padding with\n\t\t\tbits and with b) has a length that is an exact multiple\n\t\t\tof 512 bits. Equivalently, this message has a length\n\t\t\tthat is an exact multiple of 16 (32-bit) words. Let\n\t\t\tM[0 ... N-1] denote the words of the resulting message,\n\t\t\twhere N is a multiple of 16.\n\t\t*/\n\t\t// https://crypto.stackexchange.com/a/32407/54568\n\t\t/*\n\t\t\tExample case  # 1\n\t\t\t\t[0 bit: message.]\n\t\t\t\t[1 bit: 1.]\n\t\t\t\t[447 bits: 0.]\n\t\t\t\t[64 bits: message size information.]\n\n\t\t\tExample case  # 2\n\t\t\t\t[512-bits: message]\n\t\t\t\t[1 bit: 1.]\n\t\t\t\t[447 bits: 0.]\n\t\t\t\t[64 bits: message size information.]\n\n\t\t\tExample case  # 3\n\t\t\t\t[(512 - 64 = 448) bits: message.]\n\t\t\t\t[1 bit: 1.]\n\t\t\t\t[511 bits: 0.]\n\t\t\t\t[64 bits: message size information.]\n\n\t\t\tExample case  # 4\n\t\t\t\t[(512 - 65 = 447) bits: message.]\n\t\t\t\t[1 bit: 1.]\n\t\t\t\t[0 bit: 0.]\n\t\t\t\t[64 bits: message size information.]\n\t\t*/\n\t\t// The number of padding zero bits:\n\t\t//      511 - [{(message size in bits) + 64} (mod 512)]\n\t\treturn 64 - ((message_size + 8) & 0b00111111 /* 63 */);\n\t}\n\tstatic pad(message /* An ArrayBuffer. */)\n\t{\n\t\tconst message_size = message.byteLength;\n\t\tconst n_pad = RIPEMD160.get_n_pad_bytes(message_size);\n\n\t\t//  `Number.MAX_SAFE_INTEGER` is ((2 ** 53) - 1) and\n\t\t// bitwise operation in Javascript is done on 32-bits operands.\n\t\tconst divmod = (dividend, divisor) => [\n\t\t\tMath.floor(dividend / divisor),\n\t\t\tdividend % divisor\n\t\t];\n\t\t/*\nTo shift\n\n   00000000 000????? ???????? ???????? ???????? ???????? ???????? ????????\n                                     t o\n   00000000 ???????? ???????? ???????? ???????? ???????? ???????? ?????000\n\n--------------------------------------------------------------------------------\n\nMethod #1\n\n    00000000 000????? ???????? ????????  ???????? ???????? ???????? ????????\n   [00000000 000AAAAA AAAAAAAA AAAAAAAA] (<A> captured)\n   [00000000 AAAAAAAA AAAAAAAA AAAAA000] (<A> shifted)\n                         (<B> captured) [BBBBBBBB BBBBBBBB BBBBBBBB BBBBBBBB]\n                     (<B> shifted) [BBB][BBBBBBBB BBBBBBBB BBBBBBBB BBBBB000]\n   [00000000 AAAAAAAA AAAAAAAA AAAAABBB] (<A> & <B_2> merged)\n   [00000000 AAAAAAAA AAAAAAAA AAAAABBB][BBBBBBBB BBBBBBBB BBBBBBBB BBBBB000]\n    00000000 ???????? ???????? ????????  ???????? ???????? ???????? ?????000\n\n\t\tconst uint32_max_plus_1 = 0x100000000; // (2 ** 32)\n\t\tconst [\n\t\t\tmsg_byte_size_most, // Value range [0, (2 ** 21) - 1].\n\t\t\tmsg_byte_size_least // Value range [0, (2 ** 32) - 1].\n\t\t] = divmod(message_size, uint32_max_plus_1);\n\t\tconst [\n\t\t\tcarry, // Value range [0, 7].\n\t\t\tmsg_bit_size_least // Value range [0, (2 ** 32) - 8].\n\t\t] = divmod(message_byte_size_least * 8, uint32_max_plus_1);\n\t\tconst message_bit_size_most = message_byte_size_most * 8\n\t\t\t+ carry; // Value range [0, (2 ** 24) - 1].\n\n--------------------------------------------------------------------------------\n\nMethod #2\n    00000000 000????? ???????? ????????  ???????? ???????? ???????? ????????\n      [00000 000AAAAA AAAAAAAA AAAAAAAA  AAA] (<A> captured)\n                         (<B> captured) [000BBBBB BBBBBBBB BBBBBBBB BBBBBBBB]\n                          (<B> shifted) [BBBBBBBB BBBBBBBB BBBBBBBB BBBBB000]\n   [00000000 AAAAAAAA AAAAAAAA AAAAAAAA][BBBBBBBB BBBBBBBB BBBBBBBB BBBBB000]\n    00000000 ???????? ???????? ????????  ???????? ???????? ???????? ?????000\n\n\t\t*/\n\t\tconst [\n\t\t\tmsg_bit_size_most,\n\t\t\tmsg_bit_size_least\n\t\t] = divmod(message_size, 536870912 /* (2 ** 29) */)\n\t\t\t.map((x, index) => (index ? (x * 8) : x));\n\n\t\t// `ArrayBuffer.transfer()` is not supported.\n\t\tconst padded = new Uint8Array(message_size + n_pad + 8);\n\t\tpadded.set(new Uint8Array(message), 0);\n\t\tconst data_view = new DataView(padded.buffer);\n\t\tdata_view.setUint8(message_size, 0b10000000);\n\t\tdata_view.setUint32(\n\t\t\tmessage_size + n_pad,\n\t\t\tmsg_bit_size_least,\n\t\t\ttrue // Little-endian\n\t\t);\n\t\tdata_view.setUint32(\n\t\t\tmessage_size + n_pad + 4,\n\t\t\tmsg_bit_size_most,\n\t\t\ttrue // Little-endian\n\t\t);\n\n\t\treturn padded.buffer;\n\t}\n\n\tstatic f(j, x, y, z)\n\t{\n\t\tif(0 <= j && j <= 15)\n\t\t{ // Exclusive-OR\n\t\t\treturn x ^ y ^ z;\n\t\t}\n\t\tif(16 <= j && j <= 31)\n\t\t{ // Multiplexing (muxing)\n\t\t\treturn (x & y) | (~x & z);\n\t\t}\n\t\tif(32 <= j && j <= 47)\n\t\t{\n\t\t\treturn (x | ~y) ^ z;\n\t\t}\n\t\tif(48 <= j && j <= 63)\n\t\t{ // Multiplexing (muxing)\n\t\t\treturn (x & z) | (y & ~z);\n\t\t}\n\t\tif(64 <= j && j <= 79)\n\t\t{\n\t\t\treturn x ^ (y | ~z);\n\t\t}\n\t}\n\tstatic K(j)\n\t{\n\t\tif(0 <= j && j <= 15)\n\t\t{\n\t\t\treturn 0x00000000;\n\t\t}\n\t\tif(16 <= j && j <= 31)\n\t\t{\n\t\t\t// Math.floor((2 ** 30) * Math.SQRT2)\n\t\t\treturn 0x5A827999;\n\t\t}\n\t\tif(32 <= j && j <= 47)\n\t\t{\n\t\t\t// Math.floor((2 ** 30) * Math.sqrt(3))\n\t\t\treturn 0x6ED9EBA1;\n\t\t}\n\t\tif(48 <= j && j <= 63)\n\t\t{\n\t\t\t// Math.floor((2 ** 30) * Math.sqrt(5))\n\t\t\treturn 0x8F1BBCDC;\n\t\t}\n\t\tif(64 <= j && j <= 79)\n\t\t{\n\t\t\t// Math.floor((2 ** 30) * Math.sqrt(7))\n\t\t\treturn 0xA953FD4E;\n\t\t}\n\t}\n\tstatic KP(j) // K'\n\t{\n\t\tif(0 <= j && j <= 15)\n\t\t{\n\t\t\t// Math.floor((2 ** 30) * Math.cbrt(2))\n\t\t\treturn 0x50A28BE6;\n\t\t}\n\t\tif(16 <= j && j <= 31)\n\t\t{\n\t\t\t// Math.floor((2 ** 30) * Math.cbrt(3))\n\t\t\treturn 0x5C4DD124;\n\t\t}\n\t\tif(32 <= j && j <= 47)\n\t\t{\n\t\t\t// Math.floor((2 ** 30) * Math.cbrt(5))\n\t\t\treturn 0x6D703EF3;\n\t\t}\n\t\tif(48 <= j && j <= 63)\n\t\t{\n\t\t\t// Math.floor((2 ** 30) * Math.cbrt(7))\n\t\t\treturn 0x7A6D76E9;\n\t\t}\n\t\tif(64 <= j && j <= 79)\n\t\t{\n\t\t\treturn 0x00000000;\n\t\t}\n\t}\n\tstatic add_modulo32(/* ...... */)\n\t{\n\t\t// 1.  Modulo addition (addition modulo) is associative.\n\t\t//    https://proofwiki.org/wiki/Modulo_Addition_is_Associative\n \t\t// 2.  Bitwise operation in Javascript\n\t\t//    is done on 32-bits operands\n\t\t//    and results in a 32-bits value.\n\t\treturn Array\n\t\t\t.from(arguments)\n\t\t\t.reduce((a, b) => (a + b), 0) | 0;\n\t}\n\tstatic rol32(value, count)\n\t{ // Cyclic left shift (rotate) on 32-bits value.\n\t\treturn (value << count) | (value >>> (32 - count));\n\t}\n\tstatic hash(message /* An ArrayBuffer. */)\n\t{\n\t\t//////////       Padding       //////////\n\n\t\t// The padded message.\n\t\tconst padded = RIPEMD160.pad(message);\n\n\t\t//////////     Compression     //////////\n\n\t\t// Message word selectors.\n\t\tconst r = [\n\t\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t\t\t7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n\t\t\t3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n\t\t\t1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n\t\t\t4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n\t\t];\n\t\tconst rP = [ // r'\n\t\t\t5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n\t\t\t6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n\t\t\t15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n\t\t\t8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n\t\t\t12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n\t\t];\n\n\t\t// Amounts for 'rotate left' operation.\n\t\tconst s = [\n\t\t\t11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n\t\t\t7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n\t\t\t11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n\t\t\t11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n\t\t\t9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n\t\t];\n\t\tconst sP = [ // s'\n\t\t\t8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n\t\t\t9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n\t\t\t9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n\t\t\t15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n\t\t\t8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n\t\t];\n\n\t\t// The size, in bytes, of a word.\n\t\tconst word_size = 4;\n\n\t\t// The size, in bytes, of a 16-words block.\n\t\tconst block_size = 64;\n\n\t\t// The number of the 16-words blocks.\n\t\tconst t = padded.byteLength / block_size;\n\n\t\t//  The message after padding consists of t 16-word blocks that\n\t\t// are denoted with X_i[j], with 0i(t  1) and 0j15.\n\t\tconst X = (new Array(t))\n\t\t\t.fill(undefined)\n\t\t\t.map((_, i) => new Proxy(\n\t\t\t\tnew DataView(\n\t\t\t\t\tpadded, i * block_size, block_size\n\t\t\t\t), {\n\t\t\t\tget(block_view, j)\n\t\t\t\t{\n\t\t\t\t\treturn block_view.getUint32(\n\t\t\t\t\t\tj * word_size,\n\t\t\t\t\t\ttrue // Little-endian\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}));\n\n\t\t//  The result of RIPEMD-160 is contained in five 32-bit words,\n\t\t// which form the internal state of the algorithm. The final\n\t\t// content of these five 32-bit words is converted to a 160-bit\n\t\t// string, again using the little-endian convention.\n\t\tlet h = [\n\t\t\t0x67452301, // h_0\n\t\t\t0xEFCDAB89, // h_1\n\t\t\t0x98BADCFE, // h_2\n\t\t\t0x10325476, // h_3\n\t\t\t0xC3D2E1F0  // h_4\n\t\t];\n\n\t\tfor(let i = 0; i < t; ++i)\n\t\t{\n\t\t\tlet A = h[0], B = h[1], C = h[2], D = h[3], E = h[4];\n\t\t\tlet AP = A, BP = B, CP = C, DP = D, EP = E;\n\t\t\tfor(let j = 0; j < 80; ++j)\n\t\t\t{\n\t\t\t\t// Left rounds\n\t\t\t\tlet T = RIPEMD160.add_modulo32(\n\t\t\t\t\tRIPEMD160.rol32(\n\t\t\t\t\t\tRIPEMD160.add_modulo32(\n\t\t\t\t\t\t\tA,\n\t\t\t\t\t\t\tRIPEMD160.f(j, B, C, D),\n\t\t\t\t\t\t\tX[i][r[j]],\n\t\t\t\t\t\t\tRIPEMD160.K(j)\n\t\t\t\t\t\t),\n\t\t\t\t\t\ts[j]\n\t\t\t\t\t),\n\t\t\t\t\tE\n\t\t\t\t);\n\t\t\t\tA = E;\n\t\t\t\tE = D;\n\t\t\t\tD = RIPEMD160.rol32(C, 10);\n\t\t\t\tC = B;\n\t\t\t\tB = T;\n\n\t\t\t\t// Right rounds\n\t\t\t\tT = RIPEMD160.add_modulo32(\n\t\t\t\t\tRIPEMD160.rol32(\n\t\t\t\t\t\tRIPEMD160.add_modulo32(\n\t\t\t\t\t\t\tAP,\n\t\t\t\t\t\t\tRIPEMD160.f(\n\t\t\t\t\t\t\t\t79 - j,\n\t\t\t\t\t\t\t\tBP,\n\t\t\t\t\t\t\t\tCP,\n\t\t\t\t\t\t\t\tDP\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tX[i][rP[j]],\n\t\t\t\t\t\t\tRIPEMD160.KP(j)\n\t\t\t\t\t\t),\n\t\t\t\t\t\tsP[j]\n\t\t\t\t\t),\n\t\t\t\t\tEP\n\t\t\t\t);\n\t\t\t\tAP = EP;\n\t\t\t\tEP = DP;\n\t\t\t\tDP = RIPEMD160.rol32(CP, 10);\n\t\t\t\tCP = BP;\n\t\t\t\tBP = T;\n\t\t\t}\n\t\t\tlet T = RIPEMD160.add_modulo32(h[1], C, DP);\n\t\t\th[1] = RIPEMD160.add_modulo32(h[2], D, EP);\n\t\t\th[2] = RIPEMD160.add_modulo32(h[3], E, AP);\n\t\t\th[3] = RIPEMD160.add_modulo32(h[4], A, BP);\n\t\t\th[4] = RIPEMD160.add_modulo32(h[0], B, CP);\n\t\t\th[0] = T;\n\t\t}\n\n\t\t//  The final output string then consists of the concatenatation\n\t\t// of h_0, h_1, h_2, h_3, and h_4 after converting each h_i to a\n\t\t// 4-byte string using the little-endian convention.\n\t\tconst result = new ArrayBuffer(20);\n\t\tconst data_view = new DataView(result);\n\t\th.forEach((h_i, i) => data_view.setUint32(i * 4, h_i, true));\n\t\treturn result;\n\t}\n}\n\nmodule.exports = {\n\tRIPEMD160\n}\n"],"sourceRoot":""}